/** ---------- Access Control Conditions Interfaces ---------- */
import { AccessControlConditions, Chain, ConditionType, EvmContractConditions, JsonRequest, LIT_NETWORKS_KEYS, SolRpcConditions, UnifiedAccessControlConditions } from './types';
import { ILitNodeClient } from './ILitNodeClient';
export interface AccsOperatorParams {
    operator: string;
}
export interface AccsRegularParams {
    conditionType?: ConditionType;
    returnValueTest: {
        key?: string;
        comparator: string;
        value: string;
    };
    method?: string;
    params?: any[];
    chain: Chain;
}
export interface AccsDefaultParams extends AccsRegularParams {
    contractAddress?: string;
    standardContractType?: string;
    parameters?: any;
}
export interface AccsSOLV2Params extends AccsRegularParams {
    pdaKey: string;
    pdaInterface: {
        offset: string | number;
        fields: string | object;
    };
    pdaParams: [];
}
export interface ABIParams {
    name: string;
    type: string;
}
export interface FunctionABI {
    name: string;
    type?: string;
    stateMutability: string;
    inputs: Array<ABIParams | any>;
    outputs: Array<ABIParams | any>;
    constant?: string | boolean;
    payable?: boolean;
}
export interface AccsEVMParams extends AccsRegularParams {
    functionAbi: FunctionABI;
    contractAddress: string;
    functionName: string;
    functionParams: any[];
}
export interface AccsCOSMOSParams extends AccsRegularParams {
    path: string;
}
/** ---------- Auth Sig ---------- */
export interface JsonAuthSig {
    sig: string;
    derivedVia: string;
    signedMessage: string;
    address: string;
    capabilities?: [];
    algo?: [];
}
export interface CheckAndSignAuthParams {
    chain: Chain;
    resources?: any[];
    switchChain?: boolean;
    expiration?: any;
    uri?: string;
}
/** ---------- Web3 ---------- */
export interface IProvider {
    provider: any;
    account: string;
}
/** ---------- Crypto ---------- */
export interface EncryptedString {
    symmetricKey: Uint8Array;
    encryptedString: Blob;
    encryptedData?: Blob;
}
export interface EncryptedZip {
    symmetricKey: Uint8Array;
    encryptedZip: Blob;
}
export interface ThreeKeys {
    zipBlob: any;
    encryptedSymmetricKey: Uint8Array | any;
    symmetricKey: Uint8Array;
}
export interface DecryptZipFileWithMetadata {
    decryptedFile: Uint8Array;
    metadata: string;
}
export interface EncryptedFile {
    encryptedFile: Blob;
    symmetricKey: CryptoKey | Uint8Array;
}
export interface DecryptFileProps {
    file: Blob | File;
    symmetricKey: Uint8Array;
}
export interface VerifyJWTProps {
    jwt: string;
}
export interface IJWT {
    verified: boolean;
    header: object;
    payload: object;
    signature: Uint8Array;
}
export interface HumanizedAccsProps {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    tokenList?: Array<any | string>;
    myWalletAddress?: string;
}
/** ---------- Key Value Type ---------- */
export interface KV {
    [key: string]: any;
}
/** ---------- Lit Node Client ---------- */
export interface LitNodeClientConfig {
    alertWhenUnauthorized: boolean;
    minNodeCount: number;
    debug: boolean;
    bootstrapUrls: Array<string>;
    litNetwork: LIT_NETWORKS_KEYS;
    connectTimeout: number;
    defaultAuthCallback?: (authSigParams: CheckAndSignAuthParams) => Promise<JsonAuthSig>;
}
export interface CustomNetwork {
    litNetwork: LIT_NETWORKS_KEYS;
}
/**
 * Struct in rust
 * -----
 pub struct JsonExecutionRequest {
    pub code: Option<String>,
    pub ipfs_id: Option<String>,
    pub auth_sig: AuthSigItem,
    pub js_params: Option<serde_json::Value>,
}
 */
export interface JsonExecutionRequest {
    authSig: JsonAuthSig;
    jsParams: any;
    code?: string;
    ipfsId?: string;
    sessionSigs?: any;
    targetNodeRange?: number;
}
/**
 * Struct in rust
 * -----
pub struct JsonSignChainDataRequest {
    pub call_requests: Vec<web3::types::CallRequest>,
    pub chain: Chain,
    pub iat: u64,
    pub exp: u64,
}
*/
export interface JsonSignChainDataRequest {
    callRequests: Array<CallRequest>;
    chain: Chain;
    iat: number;
    exp: number;
}
/**
 * Struct in rust
 * -----
 pub struct JsonSigningResourceId {
    pub base_url: String,
    pub path: String,
    pub org_id: String,
    pub role: String,
    pub extra_data: String,
}
*/
export interface JsonSigningResourceId {
    baseUrl: string;
    path: string;
    orgId: string;
    role: string;
    extraData: string;
}
export interface JsonAccsRequest {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain?: string;
    resourceId?: JsonSigningResourceId;
    authSig?: JsonAuthSig;
    sessionSigs?: any;
}
/**
 * Struct in rust
 * -----
pub struct JsonSigningRetrieveRequest {
    pub access_control_conditions: Option<Vec<AccessControlConditionItem>>,
    pub evm_contract_conditions: Option<Vec<EVMContractConditionItem>>,
    pub sol_rpc_conditions: Option<Vec<SolRpcConditionItem>>,
    pub unified_access_control_conditions: Option<Vec<UnifiedAccessControlConditionItem>>,
    pub chain: Option<String>,
    pub resource_id: JsonSigningResourceId,
    pub auth_sig: AuthSigItem,
    pub iat: u64,
    pub exp: u64,
}
*/
export interface JsonSigningRetrieveRequest extends JsonAccsRequest {
    iat?: number;
    exp?: number;
    sessionSigs?: any;
}
export interface JsonStoreSigningRequest extends JsonAccsRequest {
    permanant?: number;
    permanent?: number;
    sessionSigs?: any;
}
/**
 * Struct in rust
 * -----
pub struct JsonSigningStoreRequest {
    pub key: String,
    pub val: String,
    pub chain: Option<String>,
    pub permanant: Option<usize>,
    pub auth_sig: AuthSigItem,
}
 */
export interface JsonSigningStoreRequest {
    key: string;
    val: string;
    chain?: string;
    permanant?: number;
    permanent?: number;
    authSig: JsonAuthSig;
}
/**
 * Struct in rust
 * -----
 pub struct JsonEncryptionRetrieveRequest {
    pub access_control_conditions: Option<Vec<AccessControlConditionItem>>,
    pub evm_contract_conditions: Option<Vec<EVMContractConditionItem>>,
    pub sol_rpc_conditions: Option<Vec<SolRpcConditionItem>>,
    pub unified_access_control_conditions: Option<Vec<UnifiedAccessControlConditionItem>>,
    pub chain: Option<String>,
    pub to_decrypt: String,
    pub auth_sig: AuthSigItem,
}
 */
export interface JsonEncryptionRetrieveRequest extends JsonAccsRequest {
    toDecrypt: string;
}
export interface ExecuteJsProps extends JsonExecutionRequest {
    debug?: boolean;
}
export interface JsonSaveEncryptionKeyRequest {
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    authSig: JsonAuthSig;
    chain: Chain;
    symmetricKey: string | Uint8Array;
    encryptedSymmetricKey?: string | Uint8Array;
    permanant?: number;
    permanent?: number;
    sessionSigs?: any;
}
export interface SignConditionECDSA {
    accessControlConditions: any;
    evmContractConditions: undefined;
    solRpcConditions: undefined;
    auth_sig: JsonAuthSig;
    chain: Chain;
    iat: number;
    exp: number;
}
/**
 *
 * An object containing the resulting signatures.  Each signature comes with the public key and the data signed.
 *
 */
export interface ExecuteJsResponse {
    signatures: any;
    decryptions: any[];
    response: string;
    logs: string;
    debug?: {
        allNodeResponses: NodeResponse[];
        allNodeLogs: NodeLog[];
        rawNodeHTTPResponses: any;
    };
}
export interface LitNodePromise {
}
export interface SendNodeCommand {
    url: string;
    data: any;
    requestId: string;
}
export interface NodeShare {
    shareIndex: any;
    unsignedJwt: any;
    signedData: any;
    decryptedData: any;
    response: any;
    logs: any;
}
export interface SuccessNodePromises {
    success: boolean;
    values: Array<NodeShare>;
}
export interface RejectedNodePromises {
    success: boolean;
    error: any;
}
export interface NodePromiseResponse {
    status?: string;
    value?: any;
    reason?: any;
}
export interface NodeError {
    error: {
        errorCode: string;
    };
}
export interface SigShare {
    sigType: any;
    shareHex: any;
    shareIndex: any;
    localX: any;
    localY: any;
    publicKey: any;
    dataSigned: any;
    siweMessage?: string;
}
export interface SignedData {
    signedData: any;
}
export interface DecryptedData {
    decryptedData: any;
}
export interface NodeResponse {
    response: any;
}
export interface NodeLog {
    logs: any;
}
export interface CallRequest {
    to: string;
    from?: string;
    data: string;
}
export interface SignedChainDataToken {
    callRequests: Array<CallRequest>;
    chain: Chain;
}
export interface NodeCommandResponse {
    url: string;
    data: JsonRequest;
}
export interface NodeCommandServerKeysResponse {
    serverPublicKey: any;
    subnetPublicKey: any;
    networkPublicKey: any;
    networkPublicKeySet: any;
}
export interface FormattedMultipleAccs {
    error: boolean;
    formattedAccessControlConditions: any;
    formattedEVMContractConditions: any;
    formattedSolRpcConditions: any;
    formattedUnifiedAccessControlConditions: any;
}
export interface SignWithECDSA {
    message: string;
    chain: Chain;
    iat: number;
    exp: number;
}
export interface ValidateAndSignECDSA {
    accessControlConditions: AccessControlConditions;
    chain: Chain;
    auth_sig: JsonAuthSig;
}
export interface HandshakeWithSgx {
    url: string;
}
export interface JsonHandshakeResponse {
    serverPubKey: string;
    subnetPubKey: string;
    networkPubKey: string;
    networkPubKeySet: string;
}
export interface EncryptFileAndZipWithMetadataProps {
    authSig: JsonAuthSig;
    accessControlConditions?: AccessControlConditions;
    evmContractConditions?: EvmContractConditions;
    solRpcConditions?: SolRpcConditions;
    unifiedAccessControlConditions?: UnifiedAccessControlConditions;
    chain: string;
    file: File;
    litNodeClient: ILitNodeClient;
    readme: string;
}
export interface DecryptZipFileWithMetadataProps {
    authSig: JsonAuthSig;
    file: File | Blob;
    litNodeClient: ILitNodeClient;
    additionalAccessControlConditions?: any[];
}
/**
 * Struct in rust
 * -----
 pub struct SessionKeySignedMessage {
    pub session_key: String,
    pub resources: Vec<String>,
    pub capabilities: Vec<String>,
    pub issued_at: String,
    pub expiration: String,
    pub node_address: String,
}
 */
export interface SessionKeySignedMessage {
    sessionKey: string;
    resources?: any[];
    capabilities: string[];
    issuedAt: string;
    expiration: string;
    nodeAddress: string;
}
export interface SessionSigsProp {
    expiration?: any;
    chain: Chain;
    resources: any[];
    sessionCapabilities?: any;
    switchChain?: boolean;
    litNodeClient: ILitNodeClient;
}
export interface SessionKeyPair {
    publicKey: string;
    secretKey: string;
}
/** ========== Session ========== */
export interface AuthMethod {
    authMethodType: number;
    accessToken: string;
}
export interface SignSessionKeyProp {
    sessionKey: string;
    authMethods: AuthMethod[];
    pkpPublicKey: string;
    authSig?: JsonAuthSig;
    expiration: string;
    resources: any;
    chainId?: number;
}
export interface GetSignSessionKeySharesProp {
    body: SessionRequestBody;
}
export interface GetSessionSigsProps {
    expiration?: any;
    chain: any;
    resources: any;
    sessionCapabilities?: any;
    switchChain?: any;
    authNeededCallback?: any;
    sessionKey?: any;
}
export interface SessionRequestBody {
    sessionKey: string;
    authMethods: Array<AuthMethod>;
    pkpPublicKey: string;
    authSig?: JsonAuthSig;
    siweMessage: string;
}
export interface WalletSig {
    signedMessage: string;
    sig: any;
}
export interface SessionSigningTemplate {
    sessionKey: string;
    resources: any[];
    capabilities: any[];
    issuedAt: string;
    expiration: string;
}
export interface GetWebAuthnAuthenticationAuthSigProps {
    verificationParams: WebAuthnAuthenticationVerificationParams;
    username: string;
    sessionKey?: any;
    expiration?: string;
    resources?: any;
}
export interface GetVerifyWebAuthnAuthenticationKeyShareProps {
    credential: WebAuthnAuthenticationVerificationParams;
    sessionPubkey: string;
    siweMessage: string;
    username: string;
}
export interface WebAuthnAuthenticationVerificationParams {
    id: string;
    rawId: string;
    response: {
        authenticatorData: string;
        clientDataJSON: string;
        signature: string;
        userHandle: string;
    };
    type: string;
    clientExtensionResults: object;
    authenticatorAttachment: AuthenticatorAttachment;
}
export declare type AuthenticatorAttachment = 'cross-platform' | 'platform';
