"use strict";
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSessionKeyPair = exports.combineBlsDecryptionShares = exports.combineEcdsaShares = exports.combineBlsShares = exports.decryptWithSymmetricKey = exports.importSymmetricKey = exports.encryptWithSymmetricKey = exports.generateSymmetricKey = void 0;
const bls_sdk_1 = require("@lit-protocol/bls-sdk");
const constants_1 = require("@lit-protocol/constants");
const wasmECDSA = require("@lit-protocol/ecdsa-sdk");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
// import nacl from 'tweetnacl';
const nacl_1 = require("@lit-protocol/nacl");
// if 'wasmExports' is not available, we need to initialize the BLS SDK
if (!globalThis.wasmExports) {
    (0, bls_sdk_1.initWasmBlsSdk)().then((exports) => {
        globalThis.wasmExports = exports;
        if (!globalThis.jestTesting) {
            (0, misc_1.log)(`✅ [BLS SDK] wasmExports loaded. ${Object.keys(exports).length} functions available. Run 'wasmExports' in the console to see them.`);
        }
    });
}
if (!globalThis.wasmECDSA) {
    wasmECDSA.initWasmEcdsaSdk().then((sdk) => {
        globalThis.wasmECDSA = sdk;
        if (!globalThis.jestTesting) {
            (0, misc_1.log)(`✅ [ECDSA SDK] wasmECDSA loaded. ${Object.keys(wasmECDSA).length} functions available. Run 'wasmECDSA' in the console to see them.`);
        }
    });
}
/** ---------- Exports ---------- */
/**
 *
 * Generate a new random symmetric key using WebCrypto subtle API.  You should only use this if you're handling your own key generation and management with Lit.  Typically, Lit handles this internally for you.
 *
 * @returns { Promise<CryptoKey> } A promise that resolves to the generated key
 */
const generateSymmetricKey = async () => {
    const symmKey = await crypto.subtle.generateKey(constants_1.SYMM_KEY_ALGO_PARAMS, true, [
        'encrypt',
        'decrypt',
    ]);
    return symmKey;
};
exports.generateSymmetricKey = generateSymmetricKey;
/**
 *
 * Encrypt a blob with a symmetric key
 *
 * @param { CryptoKey } symmKey The symmetric key
 * @param { BufferSource | Uint8Array } data The blob to encrypt
 *
 * @returns { Promise<Blob> } The encrypted blob
 */
const encryptWithSymmetricKey = async (symmKey, data) => {
    // encrypt the zip with symmetric key
    const iv = crypto.getRandomValues(new Uint8Array(16));
    const encryptedZipData = await crypto.subtle.encrypt({
        name: 'AES-CBC',
        iv,
    }, symmKey, data);
    const encryptedZipBlob = new Blob([iv, new Uint8Array(encryptedZipData)], {
        type: 'application/octet-stream',
    });
    return encryptedZipBlob;
};
exports.encryptWithSymmetricKey = encryptWithSymmetricKey;
/**
 *
 * Import a symmetric key from a Uint8Array to a webcrypto key.  You should only use this if you're handling your own key generation and management with Lit.  Typically, Lit handles this internally for you.
 *
 * @param { Uint8Array } symmKey The symmetric key to import
 *
 * @returns { Promise<CryptoKey> } A promise that resolves to the imported key
 */
const importSymmetricKey = async (symmKey) => {
    const importedSymmKey = await crypto.subtle.importKey('raw', symmKey, constants_1.SYMM_KEY_ALGO_PARAMS, true, ['encrypt', 'decrypt']);
    return importedSymmKey;
};
exports.importSymmetricKey = importSymmetricKey;
/**
 *
 * Decrypt an encrypted blob with a symmetric key.  Uses AES-CBC via SubtleCrypto
 *
 * @param { Blob } encryptedBlob The encrypted blob that should be decrypted
 * @param { CryptoKey } symmKey The symmetric key
 *
 * @returns { Uint8Array } The decrypted blob
 */
const decryptWithSymmetricKey = async (encryptedBlob, symmKey) => {
    const recoveredIv = await encryptedBlob.slice(0, 16).arrayBuffer();
    const encryptedZipArrayBuffer = await encryptedBlob.slice(16).arrayBuffer();
    const decryptedZip = await crypto.subtle.decrypt({
        name: 'AES-CBC',
        iv: recoveredIv,
    }, symmKey, encryptedZipArrayBuffer);
    return decryptedZip;
};
exports.decryptWithSymmetricKey = decryptWithSymmetricKey;
/**
 *
 * Combine BLS Shares
 *
 * @param { Array<SigShare> } sigSharesWithEverything
 * @param { string } networkPubKeySet
 *
 * @returns { any }
 *
 */
const combineBlsShares = (sigSharesWithEverything, networkPubKeySet) => {
    const pkSetAsBytes = (0, uint8arrays_1.uint8arrayFromString)(networkPubKeySet, 'base16');
    (0, misc_1.log)('pkSetAsBytes', pkSetAsBytes);
    const sigShares = sigSharesWithEverything.map((s) => ({
        shareHex: s.shareHex,
        shareIndex: s.shareIndex,
    }));
    const combinedSignatures = bls_sdk_1.wasmBlsSdkHelpers.combine_signatures(pkSetAsBytes, sigShares);
    const signature = (0, uint8arrays_1.uint8arrayToString)(combinedSignatures, 'base16');
    (0, misc_1.log)('signature is ', signature);
    return { signature };
};
exports.combineBlsShares = combineBlsShares;
/**
 *
 * Combine ECDSA Shares
 *
 * @param { SigShares | Array<SigShare> } sigShares
 *
 * @returns { any }
 *
 */
const combineEcdsaShares = (sigShares) => {
    (0, misc_1.log)("sigShares:", sigShares);
    // the public key can come from any node - it obviously will be identical from each node
    // const publicKey = sigShares[0].publicKey;
    // const dataSigned = '0x' + sigShares[0].dataSigned;
    // filter out empty shares
    const validShares = sigShares.reduce((acc, val) => {
        if (val.shareHex !== '') {
            acc.push(val);
        }
        return acc;
    }, []);
    (0, misc_1.log)("Valid Shares:", validShares);
    // if there are no valid shares, throw an error
    if (validShares.length === 0) {
        return (0, misc_1.throwError)({
            code: 'NO_VALID_SHARES',
            message: 'No valid shares to combine',
        });
    }
    // R_x & R_y values can come from any node (they will be different per node), and will generate a valid signature
    const R_x = validShares[0].localX;
    const R_y = validShares[0].localY;
    (0, misc_1.log)("R_x:", R_x);
    (0, misc_1.log)("R_y:", R_y);
    const shareHexes = validShares.map((s) => s.shareHex);
    (0, misc_1.log)('shareHexes:', shareHexes);
    const shares = JSON.stringify(shareHexes);
    (0, misc_1.log)('shares is', shares);
    let sig = '';
    try {
        sig = JSON.parse(wasmECDSA.combine_signature(R_x, R_y, shares));
    }
    catch (e) {
        (0, misc_1.log)("Failed to combine signatures:", e);
    }
    (0, misc_1.log)('signature', sig);
    return sig;
};
exports.combineEcdsaShares = combineEcdsaShares;
/**
 * //TODO: Fix 'any' types
 * Combine BLS Decryption Shares
 *
 * @param { Array<any> } decryptionShares
 * @param { string } networkPubKeySet
 * @param { string } toDecrypt
 * @param { any } provider
 *
 * @returns { any }
 *
 */
const combineBlsDecryptionShares = (decryptionShares, networkPubKeySet, toDecrypt) => {
    // -- sort the decryption shares by share index.  this is important when combining the shares.
    decryptionShares.sort((a, b) => a.shareIndex - b.shareIndex);
    // set decryption shares bytes in wasm
    decryptionShares.forEach((s, idx) => {
        wasmExports.set_share_indexes(idx, s.shareIndex);
        const shareAsBytes = (0, uint8arrays_1.uint8arrayFromString)(s.decryptionShare, 'base16');
        for (let i = 0; i < shareAsBytes.length; i++) {
            wasmExports.set_decryption_shares_byte(i, idx, shareAsBytes[i]);
        }
    });
    // -- set the public key set bytes in wasm
    const pkSetAsBytes = (0, uint8arrays_1.uint8arrayFromString)(networkPubKeySet, 'base16');
    bls_sdk_1.wasmBlsSdkHelpers.set_mc_bytes(pkSetAsBytes);
    // -- set the ciphertext bytes
    const ciphertextAsBytes = (0, uint8arrays_1.uint8arrayFromString)(toDecrypt, 'base16');
    for (let i = 0; i < ciphertextAsBytes.length; i++) {
        wasmExports.set_ct_byte(i, ciphertextAsBytes[i]);
    }
    // ========== Result ==========
    const decrypted = bls_sdk_1.wasmBlsSdkHelpers.combine_decryption_shares(decryptionShares.length, pkSetAsBytes.length, ciphertextAsBytes.length);
    return decrypted;
};
exports.combineBlsDecryptionShares = combineBlsDecryptionShares;
/**
 *
 * Generate a session key pair
 *
 * @returns { SessionKeyPair } sessionKeyPair
 */
const generateSessionKeyPair = () => {
    const keyPair = nacl_1.nacl.sign.keyPair();
    const sessionKeyPair = {
        publicKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.publicKey, 'base16'),
        secretKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.secretKey, 'base16'),
    };
    return sessionKeyPair;
};
exports.generateSessionKeyPair = generateSessionKeyPair;
//# sourceMappingURL=crypto.js.map