"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genRandomPath = exports.decimalPlaces = exports.isBrowser = exports.isNode = exports.convertLitActionsParams = exports.is = exports.numberToHex = exports.sortedObject = exports.checkIfAuthSigRequiresChainParam = exports.checkType = exports.getVarType = exports.log = exports.throwRemovedFunctionError = exports.throwError = exports.mostCommonString = exports.printError = void 0;
const constants_1 = require("@lit-protocol/constants");
const providers_1 = require("@ethersproject/providers");
const contracts_1 = require("@ethersproject/contracts");
const constants_2 = require("@lit-protocol/constants");
const logBuffer = [];
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */
const printError = (e) => {
    console.log('Error Stack', e.stack);
    console.log('Error Name', e.name);
    console.log('Error Message', e.message);
};
exports.printError = printError;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */
const mostCommonString = (arr) => {
    return arr
        .sort((a, b) => arr.filter((v) => v === a).length - arr.filter((v) => v === b).length)
        .pop();
};
exports.mostCommonString = mostCommonString;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 * TODO: remove errorCode and use standardized ILitError type instead
 *
 * @param { ILitError }
 * @property { string } message
 * @property { string } name
 * @property { string } errorCode
 */
const throwError = ({ message, name, errorCode, error, }) => {
    const errConstructorFunc = function (message, name, errorCode) {
        this.message = message;
        this.name = name;
        this.errorCode = errorCode;
    };
    throw new errConstructorFunc(message, (name = error?.name ?? name), (errorCode = error?.code ?? errorCode));
};
exports.throwError = throwError;
const throwRemovedFunctionError = (functionName) => {
    (0, exports.throwError)({
        message: `This function "${functionName}" has been removed. Please use the old SDK.`,
        error: constants_1.LIT_ERROR.REMOVED_FUNCTION_ERROR,
    });
};
exports.throwRemovedFunctionError = throwRemovedFunctionError;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */
const log = (...args) => {
    // append the prefix
    args.unshift(`[Lit-JS-SDK v${constants_2.version}]`);
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!globalThis?.litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    if (globalThis?.litConfig?.debug !== true) {
        return;
    }
    // config is loaded, and debug is true
    // if there are there are logs in buffer, print them first and empty the buffer.
    while (logBuffer.length > 0) {
        const log = logBuffer.shift() ?? '';
        console.log(...log);
    }
    console.log(...args);
};
exports.log = log;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */
const getVarType = (value) => {
    return Object.prototype.toString.call(value).slice(8, -1);
};
exports.getVarType = getVarType;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */
const checkType = ({ value, allowedTypes, paramName, functionName, throwOnError = true, }) => {
    // -- validate
    if (!allowedTypes.includes((0, exports.getVarType)(value))) {
        const message = `Expecting ${allowedTypes.join(' or ')} type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                error: constants_1.LIT_ERROR.INVALID_PARAM_TYPE,
            });
        }
        return false;
    }
    // -- else
    return true;
};
exports.checkType = checkType;
/**
 *
 * @param { object } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */
const checkIfAuthSigRequiresChainParam = (authSig, chain, functionName) => {
    (0, exports.log)('checkIfAuthSigRequiresChainParam');
    for (const key of constants_1.LIT_AUTH_SIG_CHAIN_KEYS) {
        if (key in authSig) {
            (0, exports.log)('Testing 1');
            return true;
        }
    }
    // if we're here, then we need the chain param
    if (!(0, exports.checkType)({
        value: chain,
        allowedTypes: ['String'],
        paramName: 'chain',
        functionName,
    })) {
        (0, exports.log)('Testing 2');
        return false;
    }
    (0, exports.log)('Testing 3');
    return true;
};
exports.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */
const sortedObject = (obj) => {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(exports.sortedObject);
    }
    const sortedKeys = Object.keys(obj).sort();
    const result = {};
    // NOTE: Use forEach instead of reduce for performance with large objects eg Wasm code
    sortedKeys.forEach((key) => {
        result[key] = (0, exports.sortedObject)(obj[key]);
    });
    return result;
};
exports.sortedObject = sortedObject;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */
const numberToHex = (v) => {
    return '0x' + v.toString(16);
};
exports.numberToHex = numberToHex;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @returns { Boolean } true/false
 */
const is = (value, type, paramName, functionName, throwOnError = true) => {
    if ((0, exports.getVarType)(value) !== type) {
        let message = `Expecting "${type}" type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            (0, exports.throwError)({
                message,
                name: 'invalidParamType',
                errorCode: 'invalid_param_type',
            });
        }
        return false;
    }
    return true;
};
exports.is = is;
/**
 * Convert types before sending to Lit Actions as jsParams, some JS types don't serialize well, so we will convert them before sending to the nodes
 *
 * @param { object } params.jsParams The jsParams you are sending
 * @returns { object } The jsParams object, but with any incompatible types automatically converted
 */
const convertLitActionsParams = (jsParams) => {
    // -- property
    const convertedParams = {};
    // -- execute
    for (const [key, value] of Object.entries(jsParams)) {
        const _key = key;
        const _value = value;
        // -- get value type
        const varType = (0, exports.getVarType)(_value);
        // -- case: Unit8Array
        if (varType === 'Uint8Array') {
            convertedParams[_key] = Array.from(_value);
            // -- case: Object, recurse over any objects
        }
        else if (varType === 'Object') {
            convertedParams[_key] = (0, exports.convertLitActionsParams)(_value);
        }
        // -- default
        else {
            convertedParams[_key] = _value;
        }
    }
    return convertedParams;
};
exports.convertLitActionsParams = convertLitActionsParams;
const isNode = () => {
    var isNode = false;
    // @ts-ignore
    if (typeof process === 'object') {
        // @ts-ignore
        if (typeof process.versions === 'object') {
            // @ts-ignore
            if (typeof process.versions.node !== 'undefined') {
                isNode = true;
            }
        }
    }
    return isNode;
};
exports.isNode = isNode;
const isBrowser = () => {
    return (0, exports.isNode)() === false;
};
exports.isBrowser = isBrowser;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
const decimalPlaces = async ({ contractAddress, chain, }) => {
    const rpcUrl = constants_1.LIT_CHAINS[chain].rpcUrls[0];
    const web3 = new providers_1.JsonRpcProvider(rpcUrl);
    const contract = new contracts_1.Contract(contractAddress, constants_1.ABI_ERC20.abi, web3);
    return await contract['decimals']();
};
exports.decimalPlaces = decimalPlaces;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */
const genRandomPath = () => {
    return ('/' +
        Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15));
};
exports.genRandomPath = genRandomPath;
//# sourceMappingURL=misc.js.map