import { ILitError } from '@lit-protocol/constants';
import { Chain } from '@lit-protocol/types';
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */
export declare const printError: (e: Error) => void;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */
export declare const mostCommonString: (arr: Array<any>) => any;
/**
 *
 * Standardized way to throw error in Lit Protocol projects
 * TODO: remove errorCode and use standardized ILitError type instead
 *
 * @param { ILitError }
 * @property { string } message
 * @property { string } name
 * @property { string } errorCode
 */
export declare const throwError: ({ message, name, errorCode, error, }: ILitError) => never;
declare global {
    var litConfig: any;
    var wasmExport: any;
    var wasmECDSA: any;
}
export declare const throwRemovedFunctionError: (functionName: string) => void;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */
export declare const log: (...args: any) => void;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */
export declare const getVarType: (value: any) => string;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */
export declare const checkType: ({ value, allowedTypes, paramName, functionName, throwOnError, }: {
    value: any;
    allowedTypes: Array<string> | any;
    paramName: string;
    functionName: string;
    throwOnError?: boolean | undefined;
}) => boolean;
/**
 *
 * @param { object } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */
export declare const checkIfAuthSigRequiresChainParam: (authSig: object, chain: string, functionName: string) => boolean;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */
export declare const sortedObject: (obj: any) => any;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */
export declare const numberToHex: (v: number) => string;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @returns { Boolean } true/false
 */
export declare const is: (value: any, type: string, paramName: string, functionName: string, throwOnError?: boolean) => boolean;
/**
 * Convert types before sending to Lit Actions as jsParams, some JS types don't serialize well, so we will convert them before sending to the nodes
 *
 * @param { object } params.jsParams The jsParams you are sending
 * @returns { object } The jsParams object, but with any incompatible types automatically converted
 */
export declare const convertLitActionsParams: (jsParams: object) => object;
export declare const isNode: () => boolean;
export declare const isBrowser: () => boolean;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */
export declare const decimalPlaces: ({ contractAddress, chain, }: {
    contractAddress: string;
    chain: Chain;
}) => Promise<number>;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */
export declare const genRandomPath: () => string;
