import { CustomNetwork, ExecuteJsProps, ExecuteJsResponse, FormattedMultipleAccs, GetSessionSigsProps, GetSignSessionKeySharesProp, GetVerifyWebAuthnAuthenticationKeyShareProps, HandshakeWithSgx, JsonAuthSig, JsonEncryptionRetrieveRequest, JsonExecutionRequest, JsonSaveEncryptionKeyRequest, JsonSignChainDataRequest, JsonSigningRetrieveRequest, JsonSigningStoreRequest, JsonStoreSigningRequest, KV, LitNodeClientConfig, NodeCommandResponse, NodeCommandServerKeysResponse, NodeShare, RejectedNodePromises, SendNodeCommand, SessionKeyPair, SignedChainDataToken, SignSessionKeyProp, SignConditionECDSA, SuccessNodePromises, SupportedJsonRequests, ValidateAndSignECDSA, GetWebAuthnAuthenticationAuthSigProps, CheckAndSignAuthParams } from '@lit-protocol/types';
import { SiweMessage } from 'lit-siwe';
/** ---------- Main Export Class ---------- */
export declare class NodeClient {
    #private;
    config: LitNodeClientConfig;
    connectedNodes: SetConstructor | Set<any> | any;
    serverKeys: KV | any;
    ready: boolean;
    subnetPubKey: string | null;
    networkPubKey: string | null;
    networkPubKeySet: string | null;
    defaultAuthCallback?: (authSigParams: CheckAndSignAuthParams) => Promise<JsonAuthSig>;
    constructor(args: any[LitNodeClientConfig | CustomNetwork | any]);
    /**
     *
     * Set bootstrapUrls to match the network litNetwork unless it's set to custom
     *
     * @returns { void }
     *
     */
    setCustomBootstrapUrls: () => void;
    /**
     *
     * Get either auth sig or session auth sig
     *
     */
    getAuthSigOrSessionAuthSig: ({ authSig, sessionSigs, url, }: {
        authSig: JsonAuthSig | any;
        sessionSigs: any;
        url: string;
    }) => any;
    /**
     *
     * Get the request body of the lit action
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { JsonExecutionRequest }
     *
     */
    getLitActionRequestBody: (params: ExecuteJsProps) => JsonExecutionRequest;
    /**
     *
     * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
     *
     */
    getJWTParams: () => {
        iat: number;
        exp: number;
    };
    /**
     *
     * Parse the response string to JSON
     *
     * @param { string } responseString
     *
     * @returns { any } JSON object
     *
     */
    parseResponses: (responseString: string) => any;
    /**
     *
     * Try to get the session key in the local storage,
     * if not, generates one.
     * @param { string } supposedSessionKey
     * @return { }
     */
    getSessionKey: (supposedSessionKey?: string) => SessionKeyPair;
    /**
     *
     * Get session capabilities from user, it not, generates one
     * @param { Array<any> } capabilities
     * @param { Array<any> } resources
     * @return { Array<any> }
     */
    getSessionCapabilities: (capabilities: Array<any>, resources: Array<any>) => Array<any>;
    /**
     *
     * Get expiration for session
     *
     */
    getExpiration: () => string;
    /**
     *
     * Get the signature from local storage, if not, generates one
     *
     */
    getWalletSig: ({ authNeededCallback, chain, capabilities, switchChain, expiration, sessionKeyUri, }: {
        authNeededCallback: any;
        chain: string;
        capabilities: Array<any>;
        switchChain: boolean;
        expiration: string;
        sessionKeyUri: string;
    }) => Promise<JsonAuthSig>;
    /**
     *
     * Check if a session key needs to be resigned
     *
     */
    checkNeedToResignSessionKey: ({ siweMessage, walletSignature, sessionKeyUri, resources, sessionCapabilities, }: {
        siweMessage: SiweMessage;
        walletSignature: any;
        sessionKeyUri: any;
        resources: any;
        sessionCapabilities: Array<any>;
    }) => Promise<boolean>;
    /**
     *
     * Get a random request ID
     *   *
     * @returns { string }
     *
     */
    getRequestId(): string;
    /**
     *
     * Send a command to nodes
     *
     * @param { SendNodeCommand }
     *
     * @returns { Promise<any> }
     *
     */
    sendCommandToNode: ({ url, data, requestId, }: SendNodeCommand) => Promise<any>;
    /**
     *
     * Get JS Execution Shares from Nodes
     *
     * @param { JsonExecutionRequest } params
     *
     * @returns { Promise<any> }
     */
    getJsExecutionShares: (url: string, params: JsonExecutionRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Get Chain Data Signing Shares
     *
     * @param { string } url
     * @param { JsonSignChainDataRequest } params
     *
     * @returns { Promise<any> }
     *
     */
    getChainDataSigningShare: (url: string, params: JsonSignChainDataRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Get Signing Shares from Nodes
     *
     * @param { string } url
     * @param { JsonSigningRetrieveRequest } params
     *
     * @returns { Promise<any>}
     *
     */
    getSigningShare: (url: string, params: JsonSigningRetrieveRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Ger Decryption Shares from Nodes
     *
     * @param { string } url
     * @param { JsonEncryptionRetrieveRequest } params
     *
     * @returns { Promise<any> }
     *
     */
    getDecryptionShare: (url: string, params: JsonEncryptionRetrieveRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Store signing conditions to nodes
     *
     * @param { string } url
     * @param { JsonSigningStoreRequest } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    storeSigningConditionWithNode: (url: string, params: JsonSigningStoreRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Store encryption conditions to nodes
     *
     * @param { string } urk
     * @param { JsonEncryptionStoreRequest } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    storeEncryptionConditionWithNode: (url: string, params: JsonSigningStoreRequest, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Sign Condition ECDSA
     *
     * @param { string } url
     * @param { SignConditionECDSA } params
     *
     * @returns { Promise<NodeCommandResponse> }
     *
     */
    signConditionEcdsa: (url: string, params: SignConditionECDSA, requestId: string) => Promise<NodeCommandResponse>;
    /**
     *
     * Handshake with SGX
     *
     * @param { HandshakeWithSgx } params
     *
     * @returns { Promise<NodeCommandServerKeysResponse> }
     *
     */
    handshakeWithSgx: (params: HandshakeWithSgx, requestId: string) => Promise<NodeCommandServerKeysResponse>;
    /**
     *
     * Combine Shares from network public key set and signature shares
     *
     * @param { string } networkPubKeySet
     * @param { any } signatureShares
     *
     * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
     *
     */
    combineSharesAndGetJWT: (networkPubKeySet: string, signatureShares: Array<NodeShare>) => string;
    /**
     *
     * Get different formats of access control conditions, eg. evm, sol, unified etc.
     *
     * @param { SupportedJsonRequests } params
     *
     * @returns { FormattedMultipleAccs }
     *
     */
    getFormattedAccessControlConditions: (params: SupportedJsonRequests) => FormattedMultipleAccs;
    /**
     *
     * Get hash of access control conditions
     *
     * @param { JsonStoreSigningRequest } params
     *
     * @returns { Promise<ArrayBuffer | undefined> }
     *
     */
    getHashedAccessControlConditions: (params: JsonStoreSigningRequest) => Promise<ArrayBuffer | undefined>;
    /**
     *
     * Get and gather node promises
     *
     * @param { any } callback
     *
     * @returns { Array<Promise<any>> }
     *
     */
    getNodePromises: (callback: Function) => Array<Promise<any>>;
    /**
     * Handle node promises
     *
     * @param { Array<Promise<any>> } nodePromises
     *
     * @returns { Promise<SuccessNodePromises | RejectedNodePromises> }
     *
     */
    handleNodePromises: (nodePromises: Array<Promise<any>>, minNodeCount?: number) => Promise<SuccessNodePromises | RejectedNodePromises>;
    /**
     * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { Promise<SuccessNodePromises | RejectedNodePromises> }
     *
     */
    runOnTargetedNodes: (params: ExecuteJsProps) => Promise<SuccessNodePromises | RejectedNodePromises>;
    /**
     *
     * Throw node error
     *
     * @param { RejectedNodePromises } res
     *
     * @returns { void }
     *
     */
    throwNodeError: (res: RejectedNodePromises) => void;
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    getSessionSignatures: (signedData: Array<any>) => any;
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    getSignatures: (signedData: Array<any>) => any;
    /**
     *
     * Get the decryptions from the decrypted data list
     *
     * @param { Array<any> } decryptedData
     *
     * @returns { Promise<Array<any>> }
     *
     */
    getDecryptions: (decryptedData: Array<any>) => Promise<Array<any>>;
    /**
     *
     * Get a single signature
     *
     * @param { Array<any> } shareData from all node promises
     *
     * @returns { string } signature
     *
     */
    getSignature: (shareData: Array<any>) => Promise<any>;
    /**
     *
     * Execute JS on the nodes and combine and return any resulting signatures
     *
     * @param { ExecuteJsRequest } params
     *
     * @returns { ExecuteJsResponse }
     *
     */
    executeJs: (params: ExecuteJsProps) => Promise<ExecuteJsResponse>;
    /**
     *
     * Request a signed JWT of any solidity function call from the LIT network.  There are no prerequisites for this function.  You should use this function if you need to transmit information across chains, or from a blockchain to a centralized DB or server.  The signature of the returned JWT verifies that the response is genuine.
     *
     * @param { SignedChainDataToken } params
     *
     * @returns { Promise<string>}
     */
    getSignedChainDataToken: (params: SignedChainDataToken) => Promise<string>;
    /**
     *
     * Request a signed JWT from the LIT network. Before calling this function, you must either create or know of a resource id and access control conditions for the item you wish to gain authorization for. You can create an access control condition using the saveSigningCondition function.
     *
     * @param { JsonSigningRetrieveRequest } params
     *
     * @returns { Promise<string> } final JWT
     *
     */
    getSignedToken: (params: JsonSigningRetrieveRequest) => Promise<string>;
    /**
     *
     * Associated access control conditions with a resource on the web.  After calling this function, users may use the getSignedToken function to request a signed JWT from the LIT network.  This JWT proves that the user meets the access control conditions, and is authorized to access the resource you specified in the resourceId parameter of the saveSigningCondition function.
     *
     * @param { JsonStoreSigningRequest } params
     *
     * @returns { Promise<boolean> }
     *
     */
    saveSigningCondition: (params: JsonStoreSigningRequest) => Promise<boolean>;
    /**
     *
     * Retrieve the symmetric encryption key from the LIT nodes.  Note that this will only work if the current user meets the access control conditions specified when the data was encrypted.  That access control condition is typically that the user is a holder of the NFT that corresponds to this encrypted data.  This NFT token address and ID was specified when this LIT was created.
     *
     */
    getEncryptionKey: (params: JsonEncryptionRetrieveRequest) => Promise<Uint8Array>;
    /**
     *
     * Securely save the association between access control conditions and something that you wish to decrypt
     *
     * @param { JsonSaveEncryptionKeyRequest } params
     *
     * @returns { Promise<Uint8Array> }
     *
     */
    saveEncryptionKey: (params: JsonSaveEncryptionKeyRequest) => Promise<Uint8Array>;
    /**
     *
     * Validates a condition, and then signs the condition if the validation returns true.
     * Before calling this function, you must know the on chain conditions that you wish to validate.
     *
     * @param { ValidateAndSignECDSA } params
     *
     * @returns { Promise<string> }
     */
    validateAndSignEcdsa: (params: ValidateAndSignECDSA) => Promise<string>;
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */
    connect: () => Promise<any>;
    /** ============================== SESSION ============================== */
    /**
     * Sign a session key using a PKP
     * @returns {Object} An object containing the resulting signature.
     */
    signSessionKey: (params: SignSessionKeyProp) => Promise<JsonAuthSig>;
    getSignSessionKeyShares: (url: string, params: GetSignSessionKeySharesProp, requestId: string) => Promise<any>;
    getWebAuthnAuthenticationAuthSig: (params: GetWebAuthnAuthenticationAuthSigProps) => Promise<JsonAuthSig>;
    getVerifyWebAuthnAuthenticationKeyShare: (url: string, body: GetVerifyWebAuthnAuthenticationKeyShareProps, requestId: string) => Promise<any>;
    parseResource: ({ resource, }: {
        resource: any;
    }) => {
        protocol: any;
        resourceId: any;
    };
    /**
     * Get session signatures for a set of resources
     *
     * High level, how this works:
     * 1. Generate or retrieve session key
     * 2. Generate or retrieve the wallet signature of the session key
     * 3. Sign the specific resources with the session key
     *
     * @param { GetSessionSigsProps } params
     */
    getSessionSigs: (params: GetSessionSigsProps) => Promise<any>;
}
