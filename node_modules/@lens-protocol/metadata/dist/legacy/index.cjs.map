{"version":3,"sources":["../../src/legacy/profile.ts","../../src/legacy/publication.ts","../../src/marketplace.ts","../../src/primitives.ts","../../src/utils.ts","../../src/publication/common/index.ts","../../src/publication/common/encryption.ts","../../src/MetadataAttribute.ts"],"names":["v4","z","ProfileMetadataAttributeDisplayType","serializeValue","value","ProfileMetadataAttributeSchema","ProfileMetadataSchema","hasTwoOrMore","items","toLocale","localeRegex","localeLikeRegex","LocaleRegexSchema","LocaleSchema","ctx","match","val","exact","issue","toEncryptedString","allFailed","results","r","EncryptedStringSchema","encryptable","schema","options","s","nonEmpty","result","nonEmptyStringSchema","description","encryptableStringSchema","TagSchema","toAppId","AppIdSchema","toSignature","SignatureSchema","toMarkdown","markdown","toUri","uriSchema","geoUriRegex","LatitudeSchema","LongitudeSchema","GeoURISchema","latitude","longitude","latResult","lngResult","GeoPointSchema","PhysicalAddressSchema","toEvmAddress","EvmAddressSchema","toChainId","ChainIdSchema","NetworkAddressSchema","toTokenId","TokenIdSchema","AssetSchema","AmountSchema","toProfileId","ProfileIdSchema","toPublicationId","PublicationIdSchema","MarketplaceMetadataAttributeDisplayType","MarketplaceMetadataAttributeSchema","MarketplaceMetadataSchema","NftContractType","refineNftOwnershipCondition","condition","NftOwnershipConditionSchema","ConditionComparisonOperator","Erc20OwnershipConditionSchema","EoaOwnershipConditionSchema","ProfileOwnershipConditionSchema","FollowConditionSchema","CollectConditionSchema","AdvancedContractConditionSchema","andConditionSchema","AndConditionSchema","orConditionSchema","OrConditionSchema","refineAnyCondition","c","idx","AccessConditionSchema","root","toLitEncryptionKey","LitEncryptionKeySchema","EncryptedPaths","LitEncryptionStrategySchema","PublicationEncryptionStrategySchema","BooleanAttributeSchema","DateAttributeSchema","NumberAttributeSchema","StringAttributeSchema","JSONAttributeSchema","MetadataAttributeSchema","PublicationContentWarning","PublicationMetadataCommonSchema","input","uniqueTags","PublicationMetadataVersion","PublicationMainFocus","AudioMimeType","supportedAudioMimeTypes","isSupportedAudioMimeTypes","ImageMimeType","supportedImageMimeTypes","isSupportedImageMimeType","VideoMimeType","supportedVideoMimeTypes","isSupportedVideoMimeType","AnimationUrlSchema","MediaSchema","ContentSchema","isNullish","isEmptyArray","isEmptyString","PublicationCommonSchema","media","PublicationMetadataV1Schema","data","EoaOwnershipSchema","NftOwnershipSchema","ProfileOwnershipSchema","Erc20OwnershipSchema","andCondition","orCondition","EncryptedMediaWithWrongShapeSchema","EncryptedMediaSchema","EncryptedFieldsSchema","EncryptionParamsSchema","PublicationMetadataV2CommonSchema","PublicationMetadataV2ArticleSchema","PublicationMetadataV2AudioSchema","PublicationMetadataV2EmbedSchema","PublicationMetadataV2ImageSchema","PublicationMetadataV2LinkSchema","PublicationMetadataV2TextOnlySchema","PublicationMetadataV2BaseVideoSchema","PublicationMetadataV2VideoSchema","PublicationMetadataV2ShortVideoSchema","PublicationMetadataV2Schema","PublicationMetadataSchema","v1Result","v2Result"],"mappings":"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","sourcesContent":["import { v4 } from 'uuid';\nimport { z } from 'zod';\n\nexport enum ProfileMetadataAttributeDisplayType {\n  number = 'number',\n  string = 'string',\n  date = 'date',\n}\n\nfunction serializeValue(value: unknown): string {\n  if (!value) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  return JSON.stringify(value);\n}\n\nconst ProfileMetadataAttributeSchema = z.object({\n  // On the paper ProfileMetadataAttributeDisplayType but validation never checked for it\n  // so to avoid breaking changes we are keeping it as string\n  displayType: z.string().nullable().optional().catch(null),\n\n  traitType: z.string().nullable().optional().catch(null),\n\n  value: z.unknown().transform(serializeValue),\n\n  key: z.unknown().transform(serializeValue),\n});\nexport type ProfileMetadataAttribute = z.infer<typeof ProfileMetadataAttributeSchema>;\n\n/**\n * Profile Metadata schema.\n *\n * @category Parse\n *\n * @example\n * with `parse`:\n * ```ts\n * legacy.ProfileMetadataSchema.parse(valid); // => legacy.ProfileMetadata\n *\n * legacy.ProfileMetadataSchema.parse(invalid); // => throws ZodError\n * ```\n *\n * @example\n * with `safeParse`:\n * ```ts\n * legacy.ProfileMetadataSchema.safeParse(valid);\n * // => { success: true, data: legacy.ProfileMetadata }\n *\n * legacy.ProfileMetadataSchema.safeParse(invalid);\n * // => { success: false, error: ZodError }\n * ```\n */\nexport const ProfileMetadataSchema = z\n  .object({\n    version: z.literal('1.0.0').describe('The metadata version.').catch('1.0.0'),\n\n    metadata_id: z\n      .string({\n        description:\n          'The metadata id can be anything but if your uploading to ipfs ' +\n          'you will want it to be random. Using uuid could be an option!',\n      })\n      .catch(() => v4()),\n\n    name: z.string({ description: 'The display name for the profile.' }).nullable().catch(null),\n\n    bio: z.string({ description: 'The bio for the profile.' }).nullable().optional().catch(null),\n\n    cover_picture: z.string({ description: 'Cover picture.' }).nullable().optional().catch(null),\n\n    attributes: ProfileMetadataAttributeSchema.array()\n      .describe(\n        'A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.',\n      )\n      .optional(),\n  })\n  .passthrough(); // make it more loose to allow for past profile metadata\n\nexport type ProfileMetadata = z.infer<typeof ProfileMetadataSchema>;\n","/* eslint-disable no-case-declarations */\nimport { v4 } from 'uuid';\nimport { z } from 'zod';\n\nimport { MarketplaceMetadataSchema } from '../marketplace.js';\nimport {\n  LocaleSchema,\n  Markdown,\n  nonEmptyStringSchema,\n  toAppId,\n  toMarkdown,\n} from '../primitives.js';\nimport * as latest from '../publication';\nimport {\n  ConditionComparisonOperator,\n  NftContractType,\n  PublicationContentWarning,\n} from '../publication/common';\nimport { hasTwoOrMore } from '../utils.js';\n\n// re-export under legacy namespace\nexport { ConditionComparisonOperator, NftContractType, PublicationContentWarning };\nexport { MarketplaceMetadataAttributeDisplayType } from '../marketplace.js';\nexport type { MarketplaceMetadataAttribute, MarketplaceMetadata } from '../marketplace.js';\nexport type * from '../primitives.js';\n\nexport enum PublicationMetadataVersion {\n  V1 = '1.0.0',\n  V2 = '2.0.0',\n}\n\nexport enum PublicationMainFocus {\n  ARTICLE = latest.PublicationMainFocus.ARTICLE,\n  AUDIO = latest.PublicationMainFocus.AUDIO,\n  EMBED = latest.PublicationMainFocus.EMBED,\n  IMAGE = latest.PublicationMainFocus.IMAGE,\n  LINK = latest.PublicationMainFocus.LINK,\n  SHORT_VIDEO = latest.PublicationMainFocus.SHORT_VIDEO,\n  TEXT_ONLY = latest.PublicationMainFocus.TEXT_ONLY,\n  VIDEO = latest.PublicationMainFocus.VIDEO,\n}\n\nexport enum AudioMimeType {\n  AAC = 'audio/aac',\n  FLAC = 'audio/flac',\n  MP3 = 'audio/mpeg',\n  MP4_AUDIO = 'audio/mp4',\n  OGG_AUDIO = 'audio/ogg',\n  WAV = 'audio/wav',\n  WAV_VND = 'audio/vnd.wave',\n  WEBM_AUDIO = 'audio/webm',\n}\n\nconst supportedAudioMimeTypes = Object.values(AudioMimeType);\n\nfunction isSupportedAudioMimeTypes(value: unknown): value is AudioMimeType {\n  return supportedAudioMimeTypes.includes(value as AudioMimeType);\n}\n\nexport enum ImageMimeType {\n  BMP = 'image/bmp',\n  GIF = 'image/gif',\n  HEIC = 'image/heic',\n  JPEG = 'image/jpeg',\n  JPG = 'image/jpg',\n  PNG = 'image/png',\n  SVG_XML = 'image/svg+xml',\n  TIFF = 'image/tiff',\n  WEBP = 'image/webp',\n  X_MS_BMP = 'image/x-ms-bmp',\n}\n\nconst supportedImageMimeTypes = Object.values(ImageMimeType);\n\nfunction isSupportedImageMimeType(value: unknown): value is ImageMimeType {\n  return supportedImageMimeTypes.includes(value as ImageMimeType);\n}\n\nexport enum VideoMimeType {\n  GLTF = 'model/gltf+json',\n  GLTF_BINARY = 'model/gltf-binary',\n  WEBM = 'video/webm',\n  MP4 = 'video/mp4',\n  M4V = 'video/x-m4v',\n  OGV = 'video/ogv',\n  OGG = 'video/ogg',\n  MPEG = 'video/mpeg',\n  QUICKTIME = 'video/quicktime',\n  MOV = 'video/mov',\n}\n\nconst supportedVideoMimeTypes = Object.values(VideoMimeType);\n\nfunction isSupportedVideoMimeType(value: unknown): value is VideoMimeType {\n  return supportedVideoMimeTypes.includes(value as VideoMimeType);\n}\n\nconst AnimationUrlSchema = z.string({\n  description:\n    'In spec for OpenSea and other providers - also used when using EMBED main publication focus' +\n    'A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, ' +\n    'and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. ' +\n    'Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, ' +\n    'WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.',\n});\n\n// const OpenSeaSchema = z\n//   .object({\n//     description: z\n//       .string({\n//         description:\n//           'A human-readable description of the item. It could be plain text or markdown.',\n//       })\n//       .optional()\n//       .nullable()\n//       .catch(null),\n\n//     external_url: z\n//       .string({\n//         description:\n//           `This is the URL that will appear below the asset's image on OpenSea and others etc. ` +\n//           'and will allow users to leave OpenSea and view the item on the site.',\n//       })\n//       .optional()\n//       .nullable(),\n\n//     name: z.string({ description: 'Name of the NFT item.' }),\n\n//     attributes: MarketplaceMetadataAttributeSchema.array()\n//       .describe(\n//         'These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.',\n//       )\n//       .catch([]),\n\n//     image: z\n//       .string({\n//         description: 'Marketplaces will store any NFT image here.',\n//       })\n//       .optional()\n//       .nullable()\n//       .catch(null),\n\n//     animation_url: AnimationUrlSchema.optional().nullable(),\n\n//     version: z.nativeEnum(PublicationMetadataVersion),\n//   })\n//   .passthrough(); // loose validation for any unknown fields\n\n/**\n * @internal\n */\nexport const MediaSchema = z\n  .object({\n    item: nonEmptyStringSchema('Marketplaces will store any NFT image here.'), // it can be `This publication is gated.`\n    altTag: z.string().optional().nullable().describe('The alt tag for accessibility.'),\n    cover: z\n      .string() // it can be `This publication is gated.`\n      .describe('The cover for any video or audio media.')\n      .optional()\n      .nullable()\n      .catch(null),\n    type: z.string().optional().nullable().describe('This is the mime type of the media.'),\n  })\n  .passthrough(); // loose validation for media\nexport type Media = z.infer<typeof MediaSchema>;\n/**\n * @deprecated Use `Media` instead.\n */\nexport type PublicationMetadataMedia = Media;\n\nconst ContentSchema = z\n  .string({\n    description: 'The content of a publication.',\n  })\n  .max(30000);\n\nfunction isNullish(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\nfunction isEmptyArray<T>(value: T[] | null | undefined): value is [] | null | undefined {\n  return isNullish(value) || value.length === 0;\n}\n\nfunction isEmptyString(value: string | null | undefined): value is '' | null | undefined {\n  return isNullish(value) || value.length === 0;\n}\n\nconst PublicationCommonSchema = MarketplaceMetadataSchema.extend({\n  metadata_id: z\n    .string({\n      description:\n        'The metadata_id can be anything but if your uploading to ipfs ' +\n        'you will want it to be random. Using uuid could be an option!',\n    })\n    .catch(() => v4()),\n\n  content: ContentSchema.transform((value) => value as Markdown)\n    .optional()\n    .nullable(),\n\n  media: MediaSchema.array()\n    .catch((ctx) => ctx.input.filter((media) => MediaSchema.safeParse(media).success) as Media[])\n    .optional()\n    .nullable()\n    .describe('This is lens supported attached media items to the publication.'),\n\n  // bespoke z.string() instead of AppIdSchema to emulate past behavior\n  appId: z\n    .string()\n    .max(200)\n    .transform(toAppId)\n    .optional()\n    .nullable()\n    .describe('The App Id that this publication belongs to.'),\n\n  version: z.nativeEnum(PublicationMetadataVersion),\n});\n\n/**\n * @internal\n */\nexport const PublicationMetadataV1Schema = PublicationCommonSchema.extend({\n  version: z.literal(PublicationMetadataVersion.V1, { description: 'The metadata version.' }),\n}).superRefine((data, ctx) => {\n  if (isEmptyString(data.content) && isNullish(data.image) && isEmptyArray(data.media)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['content'],\n      message:\n        'At least one between content, image, and media must be present. ' +\n        'Content must be over 1 character.',\n    });\n\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['image'],\n      message: 'At least one between content, image, and media must be present.',\n    });\n\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      path: ['media'],\n      message: 'At least one between content, image, and media must be present.',\n    });\n  }\n});\nexport type PublicationMetadataV1 = z.infer<typeof PublicationMetadataV1Schema>;\n\nconst CollectConditionSchema = z\n  .object({\n    collect: z.object({\n      publicationId: z.string().nullable(),\n      thisPublication: z.boolean().nullable().optional(),\n    }),\n  })\n  .strict();\nexport type CollectCondition = z.infer<typeof CollectConditionSchema>;\n\nconst EoaOwnershipSchema = z\n  .object({\n    eoa: z.object({\n      address: z.string(),\n    }),\n  })\n  .strict();\nexport type EoaOwnership = z.infer<typeof EoaOwnershipSchema>;\n\nconst FollowConditionSchema = z\n  .object({\n    follow: z.object({\n      profileId: z.string(),\n    }),\n  })\n  .strict();\nexport type FollowCondition = z.infer<typeof FollowConditionSchema>;\n\nconst NftOwnershipSchema = z\n  .object({\n    nft: z.object({\n      contractAddress: z.string(),\n      chainID: z.number(),\n      contractType: z.nativeEnum(NftContractType),\n      tokenIds: z.string().array().min(1).nullable().optional().catch(null),\n    }),\n  })\n  .strict();\n\nexport type NftOwnership = z.infer<typeof NftOwnershipSchema>;\n\nconst ProfileOwnershipSchema = z\n  .object({\n    profile: z.object({\n      profileId: z.string(),\n    }),\n  })\n  .strict();\nexport type ProfileOwnership = z.infer<typeof ProfileOwnershipSchema>;\n\nconst Erc20OwnershipSchema = z\n  .object({\n    token: z.object({\n      amount: z.coerce.string(),\n      chainID: z.coerce.number(),\n      condition: z.nativeEnum(ConditionComparisonOperator),\n      contractAddress: z.string(),\n      decimals: z.coerce.number(),\n    }),\n  })\n  .strict();\nexport type Erc20Ownership = z.infer<typeof Erc20OwnershipSchema>;\n\nexport type AndCondition<T> = {\n  and: {\n    criteria: [T, T, ...T[]];\n  };\n};\n\nfunction andCondition<\n  Criteria extends [z.ZodType<unknown>, z.ZodType<unknown>, ...z.ZodType<unknown>[]],\n>(options: Criteria): z.Schema<AndCondition<z.infer<Criteria[number]>>, z.ZodTypeDef, object> {\n  return z\n    .object({\n      and: z.object({\n        criteria: z\n          .union(options)\n          .array()\n          .max(5, 'Invalid AND condition: should have at most 5 conditions')\n          .refine(hasTwoOrMore, 'Invalid AND condition: should have at least 2 conditions'),\n      }),\n    })\n    .strict();\n}\n\nexport type OrCondition<T> = {\n  or: {\n    criteria: [T, T, ...T[]];\n  };\n};\n\nfunction orCondition<\n  Criteria extends [z.ZodType<unknown>, z.ZodType<unknown>, ...z.ZodType<unknown>[]],\n>(options: Criteria): z.Schema<OrCondition<z.infer<Criteria[number]>>, z.ZodTypeDef, object> {\n  return z\n    .object({\n      or: z.object({\n        criteria: z\n          .union(options)\n          .array()\n          .max(5, 'Invalid OR condition: should have at most 5 conditions')\n          .refine(hasTwoOrMore, 'Invalid OR condition: should have at least 2 conditions'),\n      }),\n    })\n    .strict();\n}\n\nconst AccessConditionSchema = orCondition([\n  CollectConditionSchema,\n  EoaOwnershipSchema,\n  FollowConditionSchema,\n  NftOwnershipSchema,\n  ProfileOwnershipSchema,\n  Erc20OwnershipSchema,\n  andCondition([\n    CollectConditionSchema,\n    EoaOwnershipSchema,\n    FollowConditionSchema,\n    NftOwnershipSchema,\n    ProfileOwnershipSchema,\n    Erc20OwnershipSchema,\n  ]),\n  orCondition([\n    CollectConditionSchema,\n    EoaOwnershipSchema,\n    FollowConditionSchema,\n    NftOwnershipSchema,\n    ProfileOwnershipSchema,\n    Erc20OwnershipSchema,\n  ]),\n]);\nexport type AccessCondition = z.infer<typeof AccessConditionSchema>;\n\nconst EncryptedMediaWithWrongShapeSchema = z\n  .object({\n    original: z.object({\n      url: nonEmptyStringSchema(),\n      cover: z.string().nullable().optional().catch(null),\n      altTag: z.string().nullable().optional().catch(null),\n      mimeType: z.string().nullable().optional().catch(null),\n    }),\n  })\n  .passthrough();\n\n/**\n * @internal\n */\nexport const EncryptedMediaSchema = z\n  .object({\n    item: z.string().describe('Marketplaces will store any NFT image here.'),\n    altTag: z.string().optional().nullable().describe('The alt tag for accessibility.'),\n    cover: z.string().describe('The cover for any video or audio media.').optional().nullable(),\n    type: z.string().optional().nullable().describe('This is the mime type of the media.'),\n  })\n  .passthrough()\n  .catch((ctx) => {\n    const result = EncryptedMediaWithWrongShapeSchema.safeParse(ctx.input);\n\n    if (result.success) {\n      return {\n        item: result.data.original.url,\n        altTag: result.data.original.altTag,\n        cover: result.data.original.cover,\n        type: result.data.original.mimeType,\n      };\n    }\n\n    return ctx.input;\n  });\nexport type EncryptedMedia = z.infer<typeof EncryptedMediaSchema>;\n\nconst EncryptedFieldsSchema = z.object({\n  content: z.string().optional().nullable(),\n  media: EncryptedMediaSchema.array().optional().nullable(),\n  image: z.string().optional().nullable(),\n  animation_url: z.string().optional().nullable(),\n  external_url: z.string().optional().nullable(),\n});\nexport type EncryptedFields = z.infer<typeof EncryptedFieldsSchema>;\n\n/**\n * @internal\n */\nexport const EncryptionParamsSchema = z.object({\n  accessCondition: AccessConditionSchema,\n  encryptedFields: EncryptedFieldsSchema,\n  providerSpecificParams: z.object({\n    encryptionKey: z.string().length(368, 'Encryption key should be 368 characters long.'),\n  }),\n});\nexport type EncryptionParams = z.infer<typeof EncryptionParamsSchema>;\n\nconst PublicationMetadataV2CommonSchema = PublicationCommonSchema.extend({\n  version: z.literal(PublicationMetadataVersion.V2, { description: 'The metadata version.' }),\n\n  locale: LocaleSchema,\n\n  content: ContentSchema.transform(toMarkdown).optional().nullable(),\n\n  contentWarning: z\n    .nativeEnum(PublicationContentWarning, { description: 'Specify a content warning.' })\n    .optional()\n    .nullable()\n    .catch(null),\n\n  mainContentFocus: z.nativeEnum(PublicationMainFocus, {\n    description: 'Main content focus that for this publication.',\n  }),\n\n  tags: z.string().array().optional().nullable().describe('Ability to tag your publication.'),\n\n  encryptionParams: EncryptionParamsSchema.optional(),\n});\n\nconst PublicationMetadataV2ArticleSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.ARTICLE),\n\n  content: ContentSchema.min(1).transform(toMarkdown),\n});\nexport type PublicationMetadataV2Article = z.infer<typeof PublicationMetadataV2ArticleSchema>;\n\nconst PublicationMetadataV2AudioSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.AUDIO),\n\n  media: MediaSchema.array()\n    .min(1)\n    .catch((ctx) => ctx.input.filter((media) => MediaSchema.safeParse(media).success) as Media[])\n    .refine(\n      (value) => value.some((media) => isSupportedAudioMimeTypes(media?.type)),\n      `Metadata ${PublicationMainFocus.AUDIO} requires an audio to be attached.`,\n    ),\n});\nexport type PublicationMetadataV2Audio = z.infer<typeof PublicationMetadataV2AudioSchema>;\n\nconst PublicationMetadataV2EmbedSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.EMBED),\n\n  animation_url: AnimationUrlSchema.optional().nullable(), // should not really be null but some publications have it as null\n});\nexport type PublicationMetadataV2Embed = z.infer<typeof PublicationMetadataV2EmbedSchema>;\n\nconst PublicationMetadataV2ImageSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.IMAGE),\n\n  media: MediaSchema.array()\n    .min(1)\n    .catch((ctx) => ctx.input.filter((media) => MediaSchema.safeParse(media).success) as Media[])\n    .refine(\n      (value) => value.some((media) => isSupportedImageMimeType(media.type)),\n      `Metadata ${PublicationMainFocus.IMAGE} requires an image to be attached.`,\n    ),\n});\nexport type PublicationMetadataV2Image = z.infer<typeof PublicationMetadataV2ImageSchema>;\n\nconst PublicationMetadataV2LinkSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.LINK),\n\n  content: ContentSchema.min(1)\n    .refine(\n      (value) => value.includes('https://'),\n      `Metadata ${PublicationMainFocus.LINK} requires a valid https link`,\n    )\n    .transform((value) => value as Markdown),\n});\nexport type PublicationMetadataV2Link = z.infer<typeof PublicationMetadataV2LinkSchema>;\n\nconst PublicationMetadataV2TextOnlySchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.TEXT_ONLY),\n\n  content: ContentSchema.min(1).transform((value) => value as Markdown),\n\n  media: z\n    .any()\n    .array()\n    .max(0, { message: 'Metadata TEXT cannot have media' })\n    .optional()\n    .nullable(),\n});\nexport type PublicationMetadataV2TextOnly = z.infer<typeof PublicationMetadataV2TextOnlySchema>;\n\nconst PublicationMetadataV2BaseVideoSchema = PublicationMetadataV2CommonSchema.extend({\n  mainContentFocus: z.union([\n    z.literal(PublicationMainFocus.VIDEO),\n    z.literal(PublicationMainFocus.SHORT_VIDEO),\n  ]),\n\n  media: MediaSchema.array()\n    .min(1)\n    .catch((ctx) => ctx.input.filter((media) => MediaSchema.safeParse(media).success) as Media[])\n    .refine(\n      (value) => value.some((media) => isSupportedVideoMimeType(media.type)),\n      `Metadata ${PublicationMainFocus.VIDEO} requires an image to be attached.`,\n    ),\n});\nconst PublicationMetadataV2VideoSchema = PublicationMetadataV2BaseVideoSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.VIDEO),\n});\nconst PublicationMetadataV2ShortVideoSchema = PublicationMetadataV2BaseVideoSchema.extend({\n  mainContentFocus: z.literal(PublicationMainFocus.SHORT_VIDEO),\n});\n\nexport type PublicationMetadataV2Video =\n  | z.infer<typeof PublicationMetadataV2VideoSchema>\n  | z.infer<typeof PublicationMetadataV2ShortVideoSchema>;\n\n/**\n * @internal\n */\nexport const PublicationMetadataV2Schema = z\n  .discriminatedUnion('mainContentFocus', [\n    PublicationMetadataV2ArticleSchema,\n    PublicationMetadataV2AudioSchema,\n    PublicationMetadataV2EmbedSchema,\n    PublicationMetadataV2ImageSchema,\n    PublicationMetadataV2LinkSchema,\n    PublicationMetadataV2TextOnlySchema,\n    PublicationMetadataV2VideoSchema,\n    PublicationMetadataV2ShortVideoSchema,\n  ])\n  .transform((data) => {\n    if (data.mainContentFocus === PublicationMainFocus.VIDEO && data.appId === 'lenstube-bytes') {\n      return {\n        ...data,\n        mainContentFocus: PublicationMainFocus.SHORT_VIDEO,\n      };\n    }\n    return data;\n  });\nexport type PublicationMetadataV2 = z.infer<typeof PublicationMetadataV2Schema>;\n\nexport type PublicationMetadata = PublicationMetadataV1 | PublicationMetadataV2;\n\n/**\n * A union of Publication Metadata v1 ad v2.\n *\n * @example\n * with `parse`:\n * ```ts\n * legacy.PublicationMetadataSchema.parse(valid); // => legacy.PublicationMetadata\n *\n * legacy.PublicationMetadataSchema.parse(invalid); // => throws ZodError\n * ```\n *\n * @example\n * with `safeParse`:\n * ```ts\n * legacy.PublicationMetadataSchema.safeParse(valid);\n * // => { success: true, data: legacy.PublicationMetadata }\n *\n * legacy.PublicationMetadataSchema.safeParse(invalid);\n * // => { success: false, error: ZodError }\n * ```\n */\nexport const PublicationMetadataSchema: z.ZodType<PublicationMetadata, z.ZodTypeDef, object> = z\n  .object({\n    // although not optional it will allow the refine function to provide better error message\n    version: z.nativeEnum(PublicationMetadataVersion),\n  })\n  .passthrough()\n  .transform((data, ctx) => {\n    switch (data.version) {\n      case PublicationMetadataVersion.V1:\n        const v1Result = PublicationMetadataV1Schema.safeParse(data);\n\n        if (!v1Result.success) {\n          v1Result.error.issues.forEach((issue) => {\n            ctx.addIssue(issue);\n          });\n          return z.NEVER;\n        }\n        return v1Result.data;\n\n      case PublicationMetadataVersion.V2:\n        const v2Result = PublicationMetadataV2Schema.safeParse(data);\n\n        if (!v2Result.success) {\n          v2Result.error.issues.forEach((issue) => {\n            ctx.addIssue(issue);\n          });\n          return z.NEVER;\n        }\n\n        return v2Result.data;\n    }\n  });\n","import { z } from 'zod';\n\nimport { Markdown, URI, markdown, nonEmptyStringSchema, uriSchema } from './primitives.js';\n\n/**\n * The display type of a marketplace metadata attribute.\n *\n * @see https://docs.opensea.io/docs/metadata-standards#attributes\n */\nexport enum MarketplaceMetadataAttributeDisplayType {\n  NUMBER = 'number',\n  STRING = 'string',\n  DATE = 'date',\n}\n\n/**\n * A marketplace metadata attribute.\n *\n * @see https://docs.opensea.io/docs/metadata-standards#attributes\n */\nexport type MarketplaceMetadataAttribute = {\n  value?: string | number | undefined;\n  display_type?: MarketplaceMetadataAttributeDisplayType | undefined;\n  trait_type?: string | undefined;\n};\n\n/**\n * @internal\n */\nexport const MarketplaceMetadataAttributeSchema: z.ZodType<\n  MarketplaceMetadataAttribute,\n  z.ZodTypeDef,\n  object\n> = z\n  .object({\n    display_type: z.nativeEnum(MarketplaceMetadataAttributeDisplayType).optional(),\n    trait_type: nonEmptyStringSchema('The name of the trait.').optional(),\n    value: z.union([z.string(), z.number()]).optional(),\n  })\n  .passthrough(); // make it more loose to allow for future marketplace extensions\n\n/**\n * The metadata standard for marketplace(s).\n *\n * @see https://docs.opensea.io/docs/metadata-standards#metadata-structure\n */\nexport type MarketplaceMetadata = {\n  /**\n   * A human-readable description of the item. It could be plain text or markdown.\n   */\n  description?: Markdown | null;\n  /**\n   * This is the URL that will appear below the asset's image on OpenSea and others etc.\n   * and will allow users to leave OpenSea and view the item on the site.\n   */\n  external_url?: URI | null;\n  /**\n   * Name of the NFT item.\n   */\n  name?: string;\n  /**\n   * These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.\n   *\n   * @see https://docs.opensea.io/docs/metadata-standards#attributes\n   */\n  attributes?: MarketplaceMetadataAttribute[];\n  /**\n   * Marketplaces will store any NFT image here.\n   */\n  image?: URI | null;\n  /**\n   * A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV,\n   * and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.\n   * `animation_url` also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas,\n   * WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.\n   */\n  animation_url?: URI | null;\n};\n\n/**\n * @internal\n */\nexport const MarketplaceMetadataSchema = z\n  .object({\n    description: markdown(\n      z.string({\n        description:\n          'A human-readable description of the item. It could be plain text or markdown.',\n      }),\n    )\n      .optional()\n      .nullable()\n      .catch(null),\n\n    external_url: uriSchema(\n      `This is the URL that will appear below the asset's image on OpenSea and others etc. ` +\n        'and will allow users to leave OpenSea and view the item on the site.',\n    )\n      .optional()\n      .nullable()\n      .catch(null),\n\n    name: z.string({ description: 'Name of the NFT item.' }).optional(),\n\n    attributes: MarketplaceMetadataAttributeSchema.array()\n      .optional()\n      .describe(\n        'These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.',\n      )\n      .catch([]),\n\n    image: uriSchema('Marketplaces will store any NFT image here.')\n      .optional()\n      .nullable()\n      .catch(null),\n\n    animation_url: uriSchema(\n      'A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, ' +\n        'and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. ' +\n        'Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, ' +\n        'WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.',\n    )\n      .optional()\n      .nullable()\n      .catch(null),\n  })\n  .passthrough(); // loose validation for any unknown fields;\n","import { z } from 'zod';\n\nimport { formatZodError } from './formatters.js';\nimport { Brand, invariant, never } from './utils.js';\n\n/**\n * A locale identifier.\n *\n * Syntax: [language]-[region] where:\n * - [language] is a lowercase ISO 639-1 language code\n * - [region] is an optional uppercase ISO 3166-1 alpha-2 country code\n *\n * You can pass just the language code, or both the language and region codes.\n *\n * @example\n * - `en` any English\n * - `en-US` English as used in the United States\n * - `en-GB` English as used in the United Kingdom\n */\nexport type Locale = Brand<string, 'Locale'>;\n/**\n * @internal\n */\nexport function toLocale(value: string): Locale {\n  return value as Locale;\n}\n\n// using ranges instead of `i` flag so that resulting JSON Schema includes case-insensitivity.\nconst localeRegex = /^[a-z]{2}(?:-[a-zA-Z]{2})?$/;\nconst localeLikeRegex = /^([a-z]{2})(?:-[A-Z0-9]{2,3})?$/i;\n\nconst LocaleRegexSchema = z\n  .string({\n    description:\n      'A Locale Identifier in the `[language]` OR `[language]-[region]` format (e.g. `en`, `en-GB`, `it`). ' +\n      '[language] MUST be in the ISO 639-1 format. [region], if provided, MUST be in the ISO 3166-1 alpha-2 format.',\n  })\n  .regex(\n    localeRegex,\n    'Should be a valid Locale Identifier. Expected `[language]` OR `[language]-[region]` format (e.g. `en`, `en-GB`, `it`). ' +\n      '[language] MUST be in the ISO 639-1 format. [region], if provided, MUST be in the ISO 3166-1 alpha-2 format.',\n  );\n\n/**\n * @internal\n */\nexport const LocaleSchema: z.ZodType<Locale, z.ZodTypeDef, unknown> = LocaleRegexSchema.catch(\n  (ctx) => {\n    // attempts to recover the language code at least\n    const match = localeLikeRegex.exec(ctx.input);\n    if (match) {\n      return match[1] as string;\n    }\n    return ctx.input;\n  },\n)\n  .superRefine((val, ctx): val is Locale => {\n    const exact = LocaleRegexSchema.safeParse(val);\n\n    if (!exact.success) {\n      exact.error.issues.forEach((issue) => {\n        ctx.addIssue(issue);\n      });\n    }\n    return z.NEVER;\n  })\n  .transform(toLocale);\n\n/**\n * A base64 encoded encrypted string value.\n */\nexport type EncryptedString = Brand<string, 'EncryptedValue'>;\nfunction toEncryptedString(value: string): EncryptedString {\n  return value as EncryptedString;\n}\n\nfunction allFailed<Input>(\n  results: z.SafeParseReturnType<Input, unknown>[],\n): results is z.SafeParseError<Input>[] {\n  return results.every((r) => !r.success);\n}\n/**\n * @internal\n */\nexport const EncryptedStringSchema = z\n  .string()\n  .describe('An encrypted value.')\n  .regex(\n    /^\\S+$/, // Approximation of Lit Encrypted value\n    'Should be a valid encrypted value.',\n  )\n  .transform(toEncryptedString);\n\n/**\n * Modifies a schema to accept an encrypted string value as well as its decrypted version.\n *\n * @internal\n */\nexport function encryptable<T extends string>(schema: z.ZodType<T, z.ZodTypeDef, unknown>) {\n  const options = [schema, EncryptedStringSchema] as const;\n  return z\n    .union(options)\n    .catch((ctx) => ctx.input as T)\n    .superRefine((val, ctx): val is T | EncryptedString => {\n      const results = options.map((s) => s.safeParse(val));\n\n      if (allFailed(results)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.invalid_union,\n          unionErrors: results.map((r) => r.error),\n        });\n      }\n      return z.NEVER;\n    });\n}\n\n/**\n * @internal\n */\nexport function nonEmpty(schema: z.ZodString): z.ZodType<string, z.ZodTypeDef, unknown> {\n  return z.preprocess((val, ctx) => {\n    const result = z.string().safeParse(val);\n\n    if (!result.success) {\n      result.error.issues.forEach((issue) => {\n        ctx.addIssue(issue);\n      });\n      return z.NEVER;\n    }\n\n    return result.data\n      .replace(\n        // eslint-disable-next-line no-control-regex\n        /^[\\u0000\\u0007\\u000e\\u000f\\u200b-\\u200d\\ufeff]*/,\n        '',\n      )\n      .replace(\n        // eslint-disable-next-line no-control-regex\n        /[\\u0000\\u0007\\u000e\\u000f\\u200b-\\u200d\\ufeff]*$/,\n        '',\n      )\n      .trim();\n  }, schema.min(1));\n}\n/**\n * @internal\n */\nexport function nonEmptyStringSchema(description?: string) {\n  return nonEmpty(z.string({ description }));\n}\n/**\n * @internal\n */\nexport function encryptableStringSchema(description: string) {\n  return encryptable(nonEmptyStringSchema(description));\n}\n\n/**\n * An arbitrary string or its encrypted version.\n *\n * For example in the context of a token-gated publication, fields of this type are encrypted.\n */\nexport type EncryptableString = string | EncryptedString;\n\n/**\n * An arbitrary label.\n *\n * All lowercased, 50 characters max.\n */\nexport type Tag = Brand<string, 'Tag'>;\n/**\n * @internal\n */\nexport function toTag(value: string): Tag {\n  return value as Tag;\n}\n/**\n * @internal\n */\nexport const TagSchema: z.ZodType<Tag, z.ZodTypeDef, string> = z\n  .string()\n  .describe('An arbitrary tag.')\n  .min(1)\n  .max(50)\n  .transform((value) => toTag(value.toLowerCase()));\n\n/**\n * A unique Lens App identifier.\n */\nexport type AppId = Brand<string, 'AppId'>;\n/**\n * @internal\n */\nexport function toAppId(value: string): AppId {\n  return value as AppId;\n}\n/**\n * @internal\n */\nexport const AppIdSchema: z.ZodType<AppId, z.ZodTypeDef, string> = z\n  .string()\n  .describe('A Lens App identifier.')\n  .min(1)\n  .max(200)\n  .transform(toAppId);\n\n/**\n * A cryptographic signature.\n */\nexport type Signature = Brand<string, 'Signature'>;\n/**\n * @internal\n */\nexport function toSignature(value: string): Signature {\n  return value as Signature;\n}\n/**\n * @internal\n */\nexport const SignatureSchema: z.ZodType<Signature, z.ZodTypeDef, unknown> = z\n  .string()\n  .min(1)\n  .describe('A cryptographic signature of the Lens metadata.')\n  .transform(toSignature);\n\n/**\n * A markdown text.\n */\nexport type Markdown = Brand<string, 'Markdown'>;\n/**\n * @internal\n */\nexport function toMarkdown(value: string): Markdown {\n  return value as Markdown;\n}\n\n/**\n * @internal\n */\nexport function markdown(\n  schema: z.ZodType<string, z.ZodTypeDef, unknown>,\n): z.ZodType<Markdown, z.ZodTypeDef, unknown> {\n  return schema.transform(toMarkdown);\n}\n\n/**\n * A markdown text or its encrypted version.\n *\n * For example in the context of a token-gated publication, fields of this type are encrypted.\n */\nexport type EncryptableMarkdown = Markdown | EncryptedString;\n\n/**\n * A Uniform Resource Identifier.\n *\n * It could be a URL pointing to a specific resource,\n * an IPFS URI (e.g. ipfs://Qm...), or an Arweave URI (e.g. ar://Qm...).\n */\nexport type URI = Brand<string, 'URI'>;\n/**\n * @internal\n */\nexport function toUri(value: string): URI {\n  return value as URI;\n}\n/**\n * @internal\n */\nexport function uriSchema(\n  description: string = 'A Uniform Resource Identifier. ',\n): z.ZodType<URI, z.ZodTypeDef, unknown> {\n  return z\n    .string({ description })\n    .min(6) // [ar://.]\n    .url({ message: 'Should be a valid URI' }) // reads url() but works well with URIs too and uses format: 'uri' in the JSON schema\n    .transform(toUri);\n}\n/**\n * @internal\n */\nexport function encryptableUriSchema(description?: string) {\n  return encryptable(uriSchema(description));\n}\n\n/**\n * A URI or its encrypted version.\n *\n * For example in the context of a token-gated publication, fields of this type are encrypted.\n */\nexport type EncryptableURI = URI | EncryptedString;\n\nconst geoUriRegex = /^geo:(-?\\d+\\.?\\d*),(-?\\d+\\.?\\d*)$/;\n\nconst LatitudeSchema = z.coerce.number({ description: 'The latitude.' }).min(-90).max(90);\n\nconst LongitudeSchema = z.coerce.number({ description: 'The longitude.' }).min(-180).max(180);\n\n/**\n * A Geographic coordinate as subset of Geo URI (RFC 5870).\n *\n * Currently only supports the `geo:lat,lng` format.\n *\n * Use the {@link geoUri} helper to create one, do not attempt to create one manually.\n *\n * @example\n * ```ts\n * 'geo:40.689247,-74.044502'\n *\n * 'geo:41.890209,12.492231'\n * ```\n *\n * @see https://tools.ietf.org/html/rfc5870\n */\nexport type GeoURI = `geo:${number},${number}`;\n/**\n * @internal\n */\nexport const GeoURISchema = z\n  .string()\n  .describe(\n    'A Geographic coordinate as subset of Geo URI (RFC 5870). ' +\n      'Currently only supports the `geo:lat,lng` format.',\n  )\n  .regex(geoUriRegex, 'Should be a Geo URI. Expected `geo:lat,lng`.')\n  .superRefine((val, ctx): val is GeoURI => {\n    const match = geoUriRegex.exec(val);\n\n    if (!match) {\n      // should never happen\n      return z.NEVER;\n    }\n\n    const [, latitude = '', longitude = ''] = match;\n\n    const latResult = LatitudeSchema.safeParse(latitude);\n    if (!latResult.success) {\n      latResult.error.issues.forEach((issue) =>\n        ctx.addIssue({\n          ...issue,\n          path: [...ctx.path, 'lat'],\n        }),\n      );\n    }\n\n    const lngResult = LongitudeSchema.safeParse(longitude);\n    if (!lngResult.success) {\n      lngResult.error.issues.forEach((issue) =>\n        ctx.addIssue({\n          ...issue,\n          path: [...ctx.path, 'lng'],\n        }),\n      );\n    }\n\n    return z.NEVER;\n  });\n\n/**\n * A geographic point on the Earth.\n */\nexport type GeoPoint = {\n  /**\n   * The latitude in decimal degrees (from -90 to +90).\n   */\n  lat: number;\n\n  /**\n   * The longitude in decimal degrees (from -180 to +180).\n   */\n  lng: number;\n};\n/**\n * @internal\n */\nexport const GeoPointSchema: z.ZodType<GeoPoint, z.ZodTypeDef, object> = z.object({\n  lat: LatitudeSchema,\n  lng: LongitudeSchema,\n});\n\n/**\n * Helper to create a Geo URI from a {@link GeoPoint}.\n *\n * @category Helpers\n * @example\n * ```ts\n * geoUri({ lat: 40.689247, lng: -74.044502 }) // 'geo:40.689247,-74.044502'\n *\n * geoUri({ lat: 41.890209, lng: 12.492231 }) // 'geo:41.890209,12.492231'\n * ```\n */\nexport function geoUri(point: GeoPoint): GeoURI {\n  const result = GeoPointSchema.safeParse(point);\n\n  if (result.success) {\n    const { lat, lng } = result.data;\n    return `geo:${lat},${lng}`;\n  }\n\n  never(formatZodError(result.error));\n}\n\n/**\n * Helper to parse a {@link GeoPoint} from a {@link GeoURI}.\n *\n * @category Helpers\n */\nexport function geoPoint(value: GeoURI): GeoPoint {\n  const uri = GeoURISchema.parse(value);\n\n  const match = geoUriRegex.exec(uri);\n\n  invariant(match, 'Invalid Geo URI format. Expected `geo:lat,lng`.');\n\n  const [, lat = '', lng = ''] = match;\n  return GeoPointSchema.parse({ lat, lng });\n}\n/**\n * @internal\n */\nexport function encryptableGeoUriSchema(description: string) {\n  return encryptable(GeoURISchema.describe(description));\n}\n\n/**\n * A Geo URI or its encrypted version.\n *\n * For example in the context of a token-gated publication, fields of this type are encrypted.\n */\nexport type EncryptableGeoURI = GeoURI | EncryptedString;\n\n/**\n * The address of a physical location.\n */\nexport type PhysicalAddress = {\n  /**\n   * The full mailing address formatted for display.\n   */\n  formatted?: EncryptableString;\n  /**\n   * The street address including house number, street name, P.O. Box,\n   * apartment or unit number and extended multi-line address information.\n   */\n  streetAddress?: EncryptableString;\n  /**\n   * The city or locality.\n   */\n  locality: EncryptableString;\n  /**\n   * The state or region.\n   */\n  region?: EncryptableString;\n  /**\n   * The zip or postal code.\n   */\n  postalCode?: EncryptableString;\n  /**\n   * The country name component.\n   */\n  country: EncryptableString;\n};\n/**\n * @internal\n */\nexport const PhysicalAddressSchema: z.ZodType<PhysicalAddress, z.ZodTypeDef, object> = z.object({\n  formatted: encryptableStringSchema('The full mailing address formatted for display.').optional(),\n  streetAddress: encryptableStringSchema(\n    'The street address including house number, street name, P.O. Box, ' +\n      'apartment or unit number and extended multi-line address information.',\n  ).optional(),\n  locality: encryptableStringSchema('The city or locality.'),\n  region: encryptableStringSchema('The state or region.').optional(),\n  postalCode: encryptableStringSchema('The zip or postal code.').optional(),\n  country: encryptableStringSchema('The country name component.'),\n});\n\n/**\n * An ISO 8601 in the JS simplified format: `YYYY-MM-DDTHH:mm:ss.sssZ`.\n */\nexport type DateTime = Brand<string, 'DateTime'>;\n/**\n * @internal\n */\nexport function toDateTime(value: string): DateTime {\n  return value as DateTime;\n}\n/**\n * @internal\n */\nexport function datetimeSchema(description: string): z.ZodType<DateTime, z.ZodTypeDef, unknown> {\n  return z.string({ description }).datetime().transform(toDateTime);\n}\n/**\n * @internal\n */\nexport function encryptableDateTimeSchema(description: string) {\n  return encryptable(datetimeSchema(description));\n}\n\n/**\n * A DateTime or its encrypted version.\n *\n * For example in the context of a token-gated publication, fields of this type are encrypted.\n */\nexport type EncryptableDateTime = DateTime | EncryptedString;\n\n/**\n * An EVM compatible address.\n */\nexport type EvmAddress = Brand<string, 'EvmAddress'>;\n/**\n * @internal\n */\nexport function toEvmAddress(value: string): EvmAddress {\n  return value as EvmAddress;\n}\n/**\n * @internal\n */\nexport const EvmAddressSchema: z.ZodType<EvmAddress, z.ZodTypeDef, unknown> = z\n  .string()\n  .length(42)\n  .describe('An EVM compatible address.')\n  .transform(toEvmAddress);\n\n/**\n * An EVM compatible Chain Id.\n */\nexport type ChainId = Brand<number, 'ChainId'>;\n/**\n * @internal\n */\nexport function toChainId(value: number): ChainId {\n  return value as ChainId;\n}\n/**\n * @internal\n */\nexport const ChainIdSchema: z.ZodType<ChainId, z.ZodTypeDef, unknown> = z\n  .number()\n  .positive()\n  .transform(toChainId);\n\n/**\n * An EVM compatible address on a specific chain.\n */\nexport type NetworkAddress = {\n  /**\n   * The chain id.\n   */\n  chainId: ChainId;\n  /**\n   * The EVM address.\n   */\n  address: EvmAddress;\n};\n/**\n * @internal\n */\nexport const NetworkAddressSchema: z.ZodType<NetworkAddress, z.ZodTypeDef, unknown> = z.object(\n  {\n    chainId: ChainIdSchema,\n    address: EvmAddressSchema,\n  },\n  {\n    description: 'An EVM compatible address on a specific chain.',\n  },\n);\n\n/**\n * An NFT token identifier.\n */\nexport type TokenId = Brand<string, 'TokenId'>;\n/**\n * @internal\n */\nexport function toTokenId(value: string): TokenId {\n  return value as TokenId;\n}\n/**\n * @internal\n */\nexport const TokenIdSchema: z.ZodType<TokenId, z.ZodTypeDef, unknown> = z\n  .string()\n  .min(1)\n  .transform(toTokenId);\n\n/**\n * A Fungible Tokens. Usually an ERC20 token.\n */\nexport type Asset = {\n  /**\n   * The asset contract address.\n   */\n  contract: NetworkAddress;\n  /**\n   * The number of decimals of the asset (e.g. 18 for WETH)\n   */\n  decimals: number;\n};\n/**\n * @internal\n */\nexport const AssetSchema: z.ZodType<Asset, z.ZodTypeDef, unknown> = z.object({\n  contract: NetworkAddressSchema,\n  decimals: z.number({ description: 'The number of decimals of the asset.' }).int().nonnegative(),\n});\n/**\n * Creates an {@link Asset}.\n *\n * @internal\n */\nexport function asset(contract: NetworkAddressDetails, decimals: number): Asset {\n  return AssetSchema.parse({ contract, decimals });\n}\n\n/**\n * An amount of a specific asset.\n */\nexport type Amount = {\n  /**\n   * The asset.\n   *\n   * See {@link asset} helper to create one.\n   */\n  asset: Asset;\n  /**\n   * The amount in the smallest unit of the given asset (e.g. wei for ETH).\n   */\n  value: string;\n};\n/**\n * @internal\n */\nexport const AmountSchema: z.ZodType<Amount, z.ZodTypeDef, unknown> = z.object(\n  {\n    asset: AssetSchema,\n    value: nonEmptyStringSchema(\n      'The amount in the smallest unit of the given asset (e.g. wei for ETH).',\n    ),\n  },\n  {\n    description: 'An amount of a specific asset.',\n  },\n);\n\nexport type NetworkAddressDetails = {\n  /**\n   * The chain id.\n   */\n  chainId: number;\n  /**\n   * The EVM address.\n   */\n  address: string;\n};\n\n/**\n * @internal\n */\nexport type AmountDetails = {\n  contract: NetworkAddressDetails;\n  decimals: number;\n  value: string;\n};\n/**\n * @internal\n */\nexport function amount(input: AmountDetails): Amount {\n  return AmountSchema.parse({\n    asset: asset(input.contract, input.decimals),\n    value: input.value,\n  });\n}\n\n/**\n * A Lens Profile identifier.\n *\n * @example\n * ```\n * 0x01\n * ```\n */\nexport type ProfileId = Brand<string, 'ProfileId'>;\n/**\n * @internal\n */\nexport function toProfileId(value: string): ProfileId {\n  return value as ProfileId;\n}\n/**\n * @internal\n */\nexport const ProfileIdSchema: z.ZodType<ProfileId, z.ZodTypeDef, unknown> = z\n  .string()\n  .min(4)\n  .transform(toProfileId);\n\n/**\n * A Lens Publication identifier.\n *\n * No Momoka publications for now.\n *\n * @example\n * ```\n * 0x01-0x01\n * ```\n */\nexport type PublicationId = Brand<string, 'PublicationId'>;\n/**\n * @internal\n */\nexport function toPublicationId(value: string): PublicationId {\n  return value as PublicationId;\n}\n/**\n * @internal\n */\nexport const PublicationIdSchema: z.ZodType<PublicationId, z.ZodTypeDef, unknown> = z\n  .string()\n  .min(9)\n  .transform(toPublicationId);\n","import { Signature } from './primitives';\n\n/**\n * Branding helper type.\n *\n * @internal\n */\nexport type Brand<T, TBrand, ReservedName extends string = '__type__'> = T & {\n  [K in ReservedName]: TBrand;\n};\n\n/**\n * Omits properties from an union type, preserving the union.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;\n\n/**\n * Overwrites properties from T1 with one from T2\n * @internal\n * @example\n * ```ts\n * Overwrite<{ foo: boolean, bar: string }, { foo: number }> // { foo: number, bar: string }\n * ```\n */\nexport type Overwrite<T1, T2> = DistributiveOmit<T1, keyof T2> & T2;\n\n/**\n * An error that occurs when a task violates a logical condition that is assumed to be true at all times.\n */\nexport class InvariantError extends Error {\n  name = 'InvariantError' as const;\n}\n\n/**\n * Asserts that the given condition is truthy\n * @internal\n *\n * @param condition - Either truthy or falsy value\n * @param message - An error message\n */\nexport function invariant(condition: unknown, message: string): asserts condition {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n/**\n * A function that throws when called.\n *\n * @param message - An error message\n */\nexport function never(message = 'Unexpected call to never()'): never {\n  throw new InvariantError(message);\n}\n\n/**\n * Specifies an object with unknown keys\n *\n * Useful when you don't care about exact props passed to the component.\n * @privateRemarks Don't use `{}` as a type. `{}` actually means \"any non-nullish value\".\n */\nexport type UnknownObject = Record<string, unknown>;\n\n/**\n * Declares an array of at least one element of the specified type.\n */\nexport type NonEmptyArray<T> = [T, ...T[]];\n\n/**\n * @internal\n */\nexport function hasAtLeastOne<T>(items: ReadonlyArray<T>): items is NonEmptyArray<T> {\n  return items.length > 0;\n}\n\n/**\n * Declares an array of at least two elements of the specified type.\n */\nexport type TwoAtLeastArray<T> = [T, T, ...T[]];\n\n/**\n * @internal\n */\nexport function hasTwoOrMore<T>(items: ReadonlyArray<T>): items is TwoAtLeastArray<T> {\n  return items.length >= 2;\n}\n\n/**\n * Beautify the  readout of all of the members of that intersection.\n *\n * As seen on tv: https://twitter.com/mattpocockuk/status/1622730173446557697\n *\n * @internal\n */\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n/**\n * @internal\n */\nexport type ShapeCheck<T> = T extends {\n  $schema: string;\n\n  lens: unknown;\n\n  signature?: Signature;\n}\n  ? T\n  : never;\n","import { z } from 'zod';\n\nimport {\n  PublicationEncryptionStrategy,\n  PublicationEncryptionStrategySchema,\n} from './encryption.js';\nimport { MetadataAttribute, MetadataAttributeSchema } from '../../MetadataAttribute.js';\nimport { MarketplaceMetadataSchema } from '../../marketplace.js';\nimport {\n  AppIdSchema,\n  LocaleSchema,\n  TagSchema,\n  nonEmptyStringSchema,\n  SignatureSchema,\n  AppId,\n  Locale,\n  Tag,\n  encryptable,\n  markdown,\n} from '../../primitives.js';\nimport { PublicationMainFocus } from '../PublicationMainFocus.js';\n\nexport * from './encryption.js';\nexport * from './license.js';\nexport * from './media.js';\nexport * from './timezones.js';\n\nexport enum PublicationContentWarning {\n  NSFW = 'NSFW',\n  SENSITIVE = 'SENSITIVE',\n  SPOILER = 'SPOILER',\n}\n\n/**\n * Common fields of a Lens primary publication.\n */\nexport type PublicationMetadataCommon = {\n  /**\n   * A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.\n   *\n   * Use a UUID if unsure.\n   */\n  id: string;\n  /**\n   * The App Id that this publication belongs to.\n   */\n  appId?: AppId;\n  /**\n   * Determine if the publication should not be shown in any feed.\n   *\n   * @defaultValue false\n   */\n  hideFromFeed?: boolean;\n  /**\n   * A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.\n   * Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.\n   */\n  attributes?: MetadataAttribute[];\n  /**\n   * The locale of the metadata.\n   */\n  locale: Locale;\n  /**\n   * The encryption strategy used to encrypt the publication.\n   *\n   * If not present, the publication is presumed to be unencrypted.\n   */\n  encryptedWith?: PublicationEncryptionStrategy;\n  /**\n   * An arbitrary list of tags.\n   */\n  tags?: Tag[];\n  /**\n   * Specify a content warning.\n   */\n  contentWarning?: PublicationContentWarning;\n};\n\nconst PublicationMetadataCommonSchema = z.object({\n  id: nonEmptyStringSchema(\n    'A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI. Use a UUID if unsure.',\n  ),\n\n  appId: AppIdSchema.optional().describe('The App Id that this publication belongs to.'),\n\n  hideFromFeed: z\n    .boolean({\n      description: 'Determine if the publication should not be shown in any feed.',\n    })\n    .optional(),\n\n  attributes: MetadataAttributeSchema.array()\n    .min(1)\n    .max(20)\n    .optional()\n    .describe(\n      'A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. ' +\n        'Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.',\n    ),\n\n  locale: LocaleSchema,\n\n  encryptedWith: PublicationEncryptionStrategySchema.optional(),\n\n  tags: z\n    .set(TagSchema) // z.set(...) sets uniqueItems: true in generated JSON Schemas\n    .max(20)\n    .catch((ctx) => ctx.input as Set<Tag>)\n    .superRefine((input, ctx) => {\n      // but needs to be corrected in code\n      const result = z.array(TagSchema).max(20).safeParse(input);\n\n      if (result.success) {\n        const uniqueTags = [...new Set(result.data)];\n        if (result.data.length > uniqueTags.length) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            fatal: true,\n            message: `Duplicate tags are not allowed: ${result.data.join(', ')}`,\n          });\n        }\n        return z.NEVER;\n      }\n\n      result.error.issues.forEach((issue) => {\n        ctx.addIssue(issue);\n      });\n    })\n    .transform((value) => [...value]) // type coercion\n    .optional()\n    .describe('An arbitrary list of tags.'),\n\n  contentWarning: z\n    .nativeEnum(PublicationContentWarning, { description: 'Specify a content warning.' })\n    .optional(),\n});\n\n/**\n * Ok, ok, don't! It's really not meant to be used outside.\n * Don't have Kenny say you we told you so.\n *\n * @internal\n */\nexport function metadataDetailsWith<\n  Augmentation extends {\n    mainContentFocus:\n      | z.ZodLiteral<PublicationMainFocus>\n      | z.ZodUnion<[z.ZodLiteral<PublicationMainFocus>, ...z.ZodLiteral<PublicationMainFocus>[]]>;\n  },\n>(augmentation: Augmentation) {\n  return PublicationMetadataCommonSchema.extend(augmentation);\n}\n\n/**\n * Ok, ok, don't! It's really not meant to be used outside.\n * Don't have Kenny say you we told you so.\n *\n * @internal\n */\nexport function publicationWith<\n  Augmentation extends {\n    $schema: z.ZodLiteral<string>;\n    lens: ReturnType<typeof metadataDetailsWith>;\n  },\n>(augmentation: Augmentation) {\n  return MarketplaceMetadataSchema.extend({\n    signature: SignatureSchema.optional(),\n    ...augmentation,\n  });\n}\n\n/**\n * Ok, ok, don't! It's really not meant to be used outside.\n * Don't have Kenny say you we told you so.\n *\n * @internal\n */\nexport function mainContentFocus<T extends PublicationMainFocus>(focus: T): z.ZodLiteral<T>;\nexport function mainContentFocus<T extends PublicationMainFocus, O extends PublicationMainFocus>(\n  ...focuses: [T, O]\n): z.ZodUnion<[z.ZodLiteral<T>, z.ZodLiteral<O>]>;\nexport function mainContentFocus(...focuses: [PublicationMainFocus, ...PublicationMainFocus[]]) {\n  const description = 'The main focus of the publication.';\n  if (focuses.length > 1) {\n    const literals = focuses.map((value) => z.literal(value)) as [\n      z.ZodLiteral<PublicationMainFocus>,\n      z.ZodLiteral<PublicationMainFocus>,\n      ...z.ZodLiteral<PublicationMainFocus>[],\n    ];\n    return z.union(literals, { description });\n  }\n  return z.literal(focuses[0], { description });\n}\n\n/**\n * @internal\n */\nexport function optionalContentSchema() {\n  return encryptable(markdown(z.string({ description: 'Optional markdown content.' }))).optional();\n}\n","/* eslint-disable no-case-declarations */\nimport { z } from 'zod';\n\nimport {\n  Amount,\n  AmountSchema,\n  EvmAddress,\n  EvmAddressSchema,\n  NetworkAddress,\n  NetworkAddressSchema,\n  ProfileId,\n  ProfileIdSchema,\n  PublicationId,\n  PublicationIdSchema,\n  TokenId,\n  TokenIdSchema,\n  nonEmptyStringSchema,\n} from '../../primitives.js';\nimport { hasTwoOrMore, Brand, TwoAtLeastArray } from '../../utils.js';\n\nexport enum EncryptionProvider {\n  LIT_PROTOCOL = 'LIT_PROTOCOL',\n}\n\nexport enum NftContractType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n}\n\nexport enum ConditionType {\n  NFT_OWNERSHIP = 'NFT_OWNERSHIP',\n  ERC20_OWNERSHIP = 'ERC20_OWNERSHIP',\n  EOA_OWNERSHIP = 'EOA_OWNERSHIP',\n  PROFILE_OWNERSHIP = 'PROFILE_OWNERSHIP',\n  FOLLOW = 'FOLLOW',\n  COLLECT = 'COLLECT',\n  ADVANCED_CONTRACT = 'ADVANCED_CONTRACT',\n  AND = 'AND',\n  OR = 'OR',\n}\n\nexport type NftOwnershipCondition = {\n  type: ConditionType.NFT_OWNERSHIP;\n  contractType: NftContractType;\n  contract: NetworkAddress;\n  tokenIds?: TokenId[];\n};\n\n/**\n * @private\n */\nexport function refineNftOwnershipCondition(\n  condition: NftOwnershipCondition,\n  ctx: z.RefinementCtx,\n) {\n  if (condition.contractType === NftContractType.ERC1155) {\n    if (condition.tokenIds === undefined || condition.tokenIds.length === 0) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'ERC1155 requires at least one token id.',\n        path: [...ctx.path, 'tokenIds'],\n      });\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport const NftOwnershipConditionSchema = z.object({\n  type: z.literal(ConditionType.NFT_OWNERSHIP),\n  contract: NetworkAddressSchema,\n  contractType: z.nativeEnum(NftContractType),\n  tokenIds: TokenIdSchema.array()\n    .min(1)\n    .optional()\n    .describe(\n      'A list of token IDs you want to check ownership of. The list is optional for ERC721, ' +\n        'you MUST provide a list of token IDs for ERC1155.',\n    ),\n});\n\nexport enum ConditionComparisonOperator {\n  EQUAL = 'EQUAL',\n  NOT_EQUAL = 'NOT_EQUAL',\n  GREATER_THAN = 'GREATER_THAN',\n  GREATER_THAN_OR_EQUAL = 'GREATER_THAN_OR_EQUAL',\n  LESS_THAN = 'LESS_THAN',\n  LESS_THAN_OR_EQUAL = 'LESS_THAN_OR_EQUAL',\n}\n\nexport type Erc20OwnershipCondition = {\n  type: ConditionType.ERC20_OWNERSHIP;\n  amount: Amount;\n  condition: ConditionComparisonOperator;\n};\n/**\n * @internal\n */\nexport const Erc20OwnershipConditionSchema = z.object({\n  type: z.literal(ConditionType.ERC20_OWNERSHIP),\n  amount: AmountSchema,\n  condition: z.nativeEnum(ConditionComparisonOperator),\n});\n\nexport type EoaOwnershipCondition = {\n  type: ConditionType.EOA_OWNERSHIP;\n  address: EvmAddress;\n};\n/**\n * @internal\n */\nexport const EoaOwnershipConditionSchema = z.object({\n  type: z.literal(ConditionType.EOA_OWNERSHIP),\n  address: EvmAddressSchema,\n});\n\nexport type ProfileOwnershipCondition = {\n  type: ConditionType.PROFILE_OWNERSHIP;\n  profileId: ProfileId;\n};\n/**\n * @internal\n */\nexport const ProfileOwnershipConditionSchema = z.object({\n  type: z.literal(ConditionType.PROFILE_OWNERSHIP),\n  profileId: ProfileIdSchema,\n});\n\nexport type FollowCondition = {\n  type: ConditionType.FOLLOW;\n  follow: ProfileId;\n};\n/**\n * @internal\n */\nexport const FollowConditionSchema = z.object({\n  type: z.literal(ConditionType.FOLLOW),\n  follow: ProfileIdSchema,\n});\n\nexport type CollectCondition = {\n  type: ConditionType.COLLECT;\n  publicationId: PublicationId;\n  thisPublication: boolean;\n};\n/**\n * @internal\n */\nexport const CollectConditionSchema = z.object({\n  type: z.literal(ConditionType.COLLECT),\n  publicationId: PublicationIdSchema, // TODO check on-chain publication ID\n  thisPublication: z.boolean().optional().default(false),\n});\n\nexport type AdvancedContractCondition = {\n  type: ConditionType.ADVANCED_CONTRACT;\n  contract: NetworkAddress;\n  functionName: string;\n  abi: string;\n  params: string[];\n  comparison: ConditionComparisonOperator;\n  value: string;\n};\n\n/**\n * @internal\n */\nexport const AdvancedContractConditionSchema = z.object({\n  type: z.literal(ConditionType.ADVANCED_CONTRACT),\n  contract: NetworkAddressSchema.describe('The contract address and chain id'),\n  functionName: z.string().min(1).describe('The name of the function you want to call'),\n  abi: z\n    .string()\n    .min(1)\n    .describe(\n      'The contract ABI. Has to be in human readable ' +\n        'single string format containing the signature of the function you want to call. See ' +\n        'https://docs.ethers.org/v5/api/utils/abi/fragments/#human-readable-abi for more info',\n    ),\n  params: z\n    .string()\n    .array()\n    .describe(\n      'The parameters to pass to the function. Must be ' +\n        'exactly matching the function arguments. You *must* pass in the `:userAddress` parameter to ' +\n        'represent the decrypter address. Any array or tuple arguments, must be stringified JSON arrays.',\n    ),\n  comparison: z\n    .nativeEnum(ConditionComparisonOperator)\n    .describe(\n      'The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL',\n    ),\n  value: z\n    .string()\n    .regex(/^(true|false|\\d{1,70})$/)\n    .describe(`The comparison value. Accepts 'true', 'false' or a number`),\n});\n\nexport type SimpleCondition =\n  | CollectCondition\n  | AdvancedContractCondition\n  | EoaOwnershipCondition\n  | Erc20OwnershipCondition\n  | FollowCondition\n  | NftOwnershipCondition\n  | ProfileOwnershipCondition;\n\ntype BaseCondition = {\n  type: ConditionType;\n};\n\ntype ComposableConditionSchema<T extends BaseCondition = BaseCondition> = z.ZodObject<\n  {\n    type: z.ZodTypeAny;\n  } & z.ZodRawShape,\n  z.UnknownKeysParam,\n  z.ZodTypeAny,\n  T\n>;\n\nexport type AndCondition<T extends BaseCondition = SimpleCondition> = {\n  type: ConditionType.AND;\n  criteria: TwoAtLeastArray<T>;\n};\n\nfunction andConditionSchema<\n  Criteria extends [\n    ComposableConditionSchema,\n    ComposableConditionSchema,\n    ...ComposableConditionSchema[],\n  ],\n>(options: Criteria): ComposableConditionSchema<AndCondition<z.infer<Criteria[number]>>> {\n  return z.object({\n    type: z.literal(ConditionType.AND),\n    criteria: z\n      .discriminatedUnion('type', options)\n      .array()\n      .max(5, 'Should have at most 5 conditions')\n      .refine(hasTwoOrMore, 'Should have at least 2 conditions'),\n  });\n}\n\n/**\n * @internal\n */\nexport const AndConditionSchema = andConditionSchema([\n  NftOwnershipConditionSchema,\n  Erc20OwnershipConditionSchema,\n  EoaOwnershipConditionSchema,\n  ProfileOwnershipConditionSchema,\n  FollowConditionSchema,\n  CollectConditionSchema,\n  AdvancedContractConditionSchema,\n]);\n\nexport type OrCondition<T extends BaseCondition = SimpleCondition> = {\n  type: ConditionType.OR;\n  criteria: TwoAtLeastArray<T>;\n};\n\nfunction orConditionSchema<\n  Criteria extends [\n    ComposableConditionSchema,\n    ComposableConditionSchema,\n    ...ComposableConditionSchema[],\n  ],\n>(options: Criteria): ComposableConditionSchema<OrCondition<z.infer<Criteria[number]>>> {\n  return z.object({\n    type: z.literal(ConditionType.OR),\n    criteria: z\n      .discriminatedUnion('type', options)\n      .array()\n      .max(5, 'Should have at most 5 conditions')\n      .refine(hasTwoOrMore, 'Should have at least 2 conditions'),\n  });\n}\n\n/**\n * @internal\n */\nexport const OrConditionSchema = orConditionSchema([\n  NftOwnershipConditionSchema,\n  Erc20OwnershipConditionSchema,\n  EoaOwnershipConditionSchema,\n  ProfileOwnershipConditionSchema,\n  FollowConditionSchema,\n  CollectConditionSchema,\n  AdvancedContractConditionSchema,\n]);\n\nexport type AnyCondition =\n  | SimpleCondition\n  | AndCondition<SimpleCondition>\n  | OrCondition<SimpleCondition>;\n\nfunction refineAnyCondition(condition: AnyCondition, ctx: z.RefinementCtx) {\n  if (condition.type === ConditionType.AND || condition.type === ConditionType.OR) {\n    condition.criteria.forEach((c, idx) =>\n      refineAnyCondition(c, { ...ctx, path: [...ctx.path, 'criteria', idx] }),\n    );\n  }\n  if (condition.type === ConditionType.NFT_OWNERSHIP) {\n    refineNftOwnershipCondition(condition, ctx);\n  }\n}\n\nexport type AccessCondition = OrCondition<AnyCondition>;\n/**\n * @internal\n */\nexport const AccessConditionSchema: z.ZodType<AccessCondition, z.ZodTypeDef, object> =\n  orConditionSchema([\n    AndConditionSchema,\n    CollectConditionSchema,\n    AdvancedContractConditionSchema,\n    EoaOwnershipConditionSchema,\n    Erc20OwnershipConditionSchema,\n    FollowConditionSchema,\n    NftOwnershipConditionSchema,\n    OrConditionSchema,\n    ProfileOwnershipConditionSchema,\n  ]).superRefine((root, ctx): root is AccessCondition => {\n    root.criteria.forEach((condition, idx) => {\n      refineAnyCondition(condition, {\n        ...ctx,\n        path: [...ctx.path, 'criteria', idx],\n      });\n    });\n    return z.NEVER;\n  });\n\n/**\n * A symmetric encryption key.\n */\nexport type LitEncryptionKey = Brand<string, 'LitEncryptionKey'>;\n/**\n * @internal\n */\nexport function toLitEncryptionKey(value: string): LitEncryptionKey {\n  return value as LitEncryptionKey;\n}\n/**\n * @internal\n */\nexport const LitEncryptionKeySchema: z.Schema<LitEncryptionKey, z.ZodTypeDef, string> = z\n  .string()\n  .describe('A symmetric encryption key.')\n  .length(368, 'Encryption key should be 368 characters long.')\n  .transform(toLitEncryptionKey);\n\n/**\n * @internal\n */\nexport const EncryptedPaths = nonEmptyStringSchema(\n  'An encrypted path is a string of keys separated by . that describe ' +\n    'a path to a value in a JSON object (e.g. lens.attachments.0.item.url, lens.content).',\n)\n  .array()\n  .min(1);\nexport type EncryptedPaths = z.infer<typeof EncryptedPaths>;\n\nexport type LitEncryptionStrategy = {\n  provider: EncryptionProvider;\n  encryptionKey: LitEncryptionKey;\n  accessCondition: AccessCondition;\n  encryptedPaths: string[];\n};\n/**\n * @internal\n */\nexport const LitEncryptionStrategySchema = z.object(\n  {\n    provider: z.literal(EncryptionProvider.LIT_PROTOCOL),\n    encryptionKey: LitEncryptionKeySchema,\n    accessCondition: AccessConditionSchema,\n    encryptedPaths: EncryptedPaths,\n  },\n  {\n    description: 'Publication encryption strategy powered by the LIT Protocol.',\n  },\n);\n\n/**\n * The publication encryption strategy.\n *\n * This is normally populated by the Lens SDK so the vast majority of developers will not need to use this directly.\n */\nexport type PublicationEncryptionStrategy = LitEncryptionStrategy;\n\n/**\n * @internal\n */\nexport const PublicationEncryptionStrategySchema: z.ZodType<\n  PublicationEncryptionStrategy,\n  z.ZodTypeDef,\n  object\n> = z.discriminatedUnion('provider', [LitEncryptionStrategySchema]);\n","import { z } from 'zod';\n\nimport { nonEmptyStringSchema } from './primitives.js';\n\n/**\n * The type of a metadata attribute.\n */\nexport enum MetadataAttributeType {\n  BOOLEAN = 'Boolean',\n  DATE = 'Date',\n  NUMBER = 'Number',\n  STRING = 'String',\n  JSON = 'JSON',\n}\n\nexport type BooleanAttribute = {\n  /**\n   * A JS boolean value serialized as string. It's consumer responsibility to parse it.\n   */\n  value: 'true' | 'false';\n  /**\n   * Union discriminant.\n   */\n  type: MetadataAttributeType.BOOLEAN;\n  /**\n   * The attribute's unique identifier.\n   */\n  key: string;\n};\n/**\n * @internal\n */\nexport const BooleanAttributeSchema = z.object({\n  type: z.literal(MetadataAttributeType.BOOLEAN),\n  key: nonEmptyStringSchema(\"The attribute's unique identifier.\"),\n  value: z\n    .enum(['true', 'false'])\n    .describe(\"A JS boolean value serialized as string. It's consumer responsibility to parse it.\"),\n});\n\nexport type DateAttribute = {\n  /**\n   * A valid ISO 8601 date string.  It's consumer responsibility to parse it.\n   */\n  value: string;\n  /**\n   * Union discriminant.\n   */\n  type: MetadataAttributeType.DATE;\n  /**\n   * The attribute's unique identifier.\n   */\n  key: string;\n};\n/**\n * @internal\n */\nexport const DateAttributeSchema = z.object({\n  type: z.literal(MetadataAttributeType.DATE),\n  key: nonEmptyStringSchema(\"The attribute's unique identifier.\"),\n  value: z\n    .string()\n    .datetime()\n    .describe(\"A valid ISO 8601 date string.  It's consumer responsibility to parse it.\"),\n});\n\nexport type NumberAttribute = {\n  /**\n   * A valid JS number serialized as string. It's consumer responsibility to parse it.\n   *\n   * @example\n   * ```ts\n   * '42'\n   *\n   * '42n'\n   *\n   * '42.42'\n   * ```\n   */\n  value: string;\n  /**\n   * Union discriminant.\n   */\n  type: MetadataAttributeType.NUMBER;\n  /**\n   * The attribute's unique identifier.\n   */\n  key: string;\n};\n/**\n * @internal\n */\nexport const NumberAttributeSchema = z.object({\n  type: z.literal(MetadataAttributeType.NUMBER),\n  key: nonEmptyStringSchema(\"The attribute's unique identifier.\"), // TODO generalize and share\n  value: nonEmptyStringSchema(\n    \"A valid JS number serialized as string. It's consumer responsibility to parse it.\",\n  ),\n});\n\nexport type StringAttribute = {\n  /**\n   * Any string value.\n   */\n  value: string;\n  /**\n   * Union discriminant.\n   */\n  type: MetadataAttributeType.STRING;\n  /**\n   * The attribute's unique identifier.\n   */\n  key: string;\n};\n/**\n * @internal\n */\nexport const StringAttributeSchema = z.object({\n  type: z.literal(MetadataAttributeType.STRING),\n  key: nonEmptyStringSchema(\"The attribute's unique identifier.\"),\n  value: nonEmptyStringSchema('A string value.'),\n});\n\nexport type JSONAttribute = {\n  /**\n   * A JSON string. It's consumer responsibility to validate and parse it.\n   */\n  value: string;\n  /**\n   * Union discriminant.\n   */\n  type: MetadataAttributeType.JSON;\n  /**\n   * Union discriminant.\n   */\n  /**\n   * The attribute's unique identifier.\n   */\n  key: string;\n};\n/**\n * @internal\n */\nexport const JSONAttributeSchema = z.object({\n  type: z.literal(MetadataAttributeType.JSON),\n  key: nonEmptyStringSchema(\"The attribute's unique identifier.\"),\n  value: nonEmptyStringSchema(\n    \"A JSON string. It's consumer responsibility to validate and parse it.\",\n  ),\n});\n\n/**\n * A Lens metadata attribute.\n */\nexport type MetadataAttribute =\n  | BooleanAttribute\n  | DateAttribute\n  | NumberAttribute\n  | StringAttribute\n  | JSONAttribute;\n\nexport const MetadataAttributeSchema = z.discriminatedUnion('type', [\n  BooleanAttributeSchema,\n  DateAttributeSchema,\n  NumberAttributeSchema,\n  StringAttributeSchema,\n  JSONAttributeSchema,\n]);\n"]}